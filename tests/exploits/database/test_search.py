"""Tests for ExploitSearch class."""

import pytest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
from exploits.database.search import ExploitSearch


class TestExploitSearch:
    """Test suite for ExploitSearch."""

    def test_search_exploitdb_with_searchsploit(self):
        """Test searching ExploitDB via searchsploit"""
        searcher = ExploitSearch()

        # Mock subprocess call to searchsploit
        mock_result = {
            "RESULTS_EXPLOIT": [
                {
                    "Title": "WordPress Plugin XYZ - SQL Injection",
                    "EDB-ID": "12345",
                    "Date": "2021-01-15",
                    "Author": "John Doe",
                    "Type": "webapps",
                    "Platform": "php",
                    "Path": "/usr/share/exploitdb/exploits/php/webapps/12345.txt"
                }
            ]
        }

        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(
                returncode=0,
                stdout='{"RESULTS_EXPLOIT": [{"Title": "WordPress Plugin XYZ - SQL Injection", "EDB-ID": "12345", "Date": "2021-01-15", "Author": "John Doe", "Type": "webapps", "Platform": "php", "Path": "/usr/share/exploitdb/exploits/php/webapps/12345.txt"}]}'
            )

            results = searcher.search_exploitdb("wordpress sql injection")

            assert isinstance(results, list)
            assert len(results) > 0
            assert results[0]['title'] == "WordPress Plugin XYZ - SQL Injection"
            assert results[0]['id'] == "EDB-12345"
            assert results[0]['source'] == "exploitdb"
            assert 'date' in results[0]
            assert 'author' in results[0]

    def test_search_exploitdb_no_searchsploit(self):
        """Test handling when searchsploit is not available"""
        searcher = ExploitSearch()

        with patch('subprocess.run', side_effect=FileNotFoundError):
            results = searcher.search_exploitdb("test query")

            # Should return empty list when tool not available
            assert isinstance(results, list)
            assert len(results) == 0

    def test_search_github_pocs(self):
        """Test searching GitHub for POC exploits"""
        searcher = ExploitSearch()

        # Mock GitHub API response
        mock_response = {
            "items": [
                {
                    "full_name": "hacker/cve-2021-44228-poc",
                    "description": "Log4Shell exploit POC",
                    "html_url": "https://github.com/hacker/cve-2021-44228-poc",
                    "stargazers_count": 500,
                    "created_at": "2021-12-10T00:00:00Z"
                }
            ]
        }

        with patch('requests.get') as mock_get:
            mock_get.return_value = Mock(
                status_code=200,
                json=lambda: mock_response
            )

            results = searcher.search_github_pocs("CVE-2021-44228")

            assert isinstance(results, list)
            assert len(results) > 0
            assert results[0]['title'] == "hacker/cve-2021-44228-poc"
            assert results[0]['source'] == "github"
            assert results[0]['url'] == "https://github.com/hacker/cve-2021-44228-poc"
            assert results[0]['stars'] == 500

    def test_search_github_pocs_api_error(self):
        """Test handling GitHub API errors"""
        searcher = ExploitSearch()

        with patch('requests.get', side_effect=Exception("API Error")):
            results = searcher.search_github_pocs("test query")

            assert isinstance(results, list)
            assert len(results) == 0

    def test_search_metasploit(self):
        """Test searching Metasploit modules"""
        searcher = ExploitSearch()

        # Mock msfconsole output
        mock_output = """
Matching Modules
================

   #  Name                                          Disclosure Date  Rank    Check  Description
   -  ----                                          ---------------  ----    -----  -----------
   0  exploit/windows/smb/ms17_010_eternalblue      2017-03-14       average  Yes    MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption
"""

        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(
                returncode=0,
                stdout=mock_output
            )

            results = searcher.search_metasploit("ms17-010")

            assert isinstance(results, list)
            assert len(results) > 0
            assert results[0]['name'] == "exploit/windows/smb/ms17_010_eternalblue"
            assert results[0]['source'] == "metasploit"
            assert 'rank' in results[0]

    def test_search_metasploit_not_available(self):
        """Test handling when Metasploit is not available"""
        searcher = ExploitSearch()

        with patch('subprocess.run', side_effect=FileNotFoundError):
            results = searcher.search_metasploit("test query")

            assert isinstance(results, list)
            assert len(results) == 0

    def test_download_exploit_exploitdb(self):
        """Test downloading exploit from ExploitDB"""
        searcher = ExploitSearch()
        output_path = "/tmp/test_exploit.txt"

        with patch.object(searcher.exploitdb, 'download_exploit', return_value=True):
            success = searcher.download_exploit("EDB-12345", output_path)

            assert success is True

    def test_download_exploit_github(self):
        """Test downloading exploit from GitHub"""
        searcher = ExploitSearch()
        output_path = "/tmp/test_poc.py"

        mock_content = b"#!/usr/bin/env python3\n# POC code here"

        with patch('requests.get') as mock_get:
            mock_get.return_value = Mock(
                status_code=200,
                content=mock_content
            )

            with patch('pathlib.Path.write_bytes') as mock_write:
                success = searcher.download_exploit(
                    "https://github.com/user/repo/blob/main/poc.py",
                    output_path
                )

                assert success is True

    def test_download_exploit_invalid_id(self):
        """Test handling invalid exploit ID"""
        searcher = ExploitSearch()

        success = searcher.download_exploit("INVALID-123", "/tmp/test.txt")

        assert success is False

    def test_search_all_sources(self):
        """Test searching all sources at once"""
        searcher = ExploitSearch()

        with patch.object(searcher, 'search_exploitdb', return_value=[{"id": "EDB-1", "source": "exploitdb"}]):
            with patch.object(searcher, 'search_github_pocs', return_value=[{"id": "GH-1", "source": "github"}]):
                with patch.object(searcher, 'search_metasploit', return_value=[{"id": "MSF-1", "source": "metasploit"}]):
                    results = searcher.search_all("test query")

                    assert isinstance(results, dict)
                    assert 'exploitdb' in results
                    assert 'github' in results
                    assert 'metasploit' in results
                    assert len(results['exploitdb']) == 1
                    assert len(results['github']) == 1
                    assert len(results['metasploit']) == 1

    def test_format_results(self):
        """Test result formatting for consistent output"""
        searcher = ExploitSearch()

        # Test formatting different source types
        exploitdb_result = {
            "Title": "Test Exploit",
            "EDB-ID": "12345",
            "Date": "2021-01-01"
        }

        formatted = searcher._format_exploitdb_result(exploitdb_result)

        assert formatted['source'] == 'exploitdb'
        assert formatted['id'] == 'EDB-12345'
        assert 'title' in formatted
        assert 'date' in formatted
