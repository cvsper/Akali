"""Tests for ExploitDB integration."""

import pytest
from unittest.mock import Mock, patch
from exploits.database.exploitdb import ExploitDBClient


class TestExploitDBClient:
    """Test suite for ExploitDB client."""

    def test_check_available_with_searchsploit(self):
        """Test checking if searchsploit is available"""
        client = ExploitDBClient()

        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(returncode=0)

            assert client.check_available() is True

    def test_check_available_without_searchsploit(self):
        """Test handling when searchsploit is not installed"""
        client = ExploitDBClient()

        with patch('subprocess.run', side_effect=FileNotFoundError):
            assert client.check_available() is False

    def test_search_by_term(self):
        """Test searching by term"""
        client = ExploitDBClient()

        mock_output = '{"RESULTS_EXPLOIT": [{"Title": "Test", "EDB-ID": "123"}]}'

        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(returncode=0, stdout=mock_output)

            results = client.search(query="wordpress")

            assert isinstance(results, list)
            assert len(results) > 0

    def test_search_by_cve(self):
        """Test searching by CVE"""
        client = ExploitDBClient()

        mock_output = '{"RESULTS_EXPLOIT": [{"Title": "CVE-2021-1234 Exploit", "EDB-ID": "456"}]}'

        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(returncode=0, stdout=mock_output)

            results = client.search_by_cve("CVE-2021-1234")

            assert isinstance(results, list)
            assert len(results) > 0

    def test_get_exploit_path(self):
        """Test getting local path to exploit"""
        client = ExploitDBClient()

        mock_output = '{"RESULTS_EXPLOIT": [{"Path": "/usr/share/exploitdb/exploits/php/12345.txt"}]}'

        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(returncode=0, stdout=mock_output)

            path = client.get_exploit_path("12345")

            assert path is not None
            assert isinstance(path, str)

    def test_download_exploit(self):
        """Test downloading/copying exploit"""
        client = ExploitDBClient()

        with patch('shutil.copy2') as mock_copy:
            with patch.object(client, 'get_exploit_path', return_value="/usr/share/exploitdb/exploits/test.txt"):
                success = client.download_exploit("12345", "/tmp/exploit.txt")

                assert success is True
                mock_copy.assert_called_once()

    def test_parse_json_output(self):
        """Test parsing searchsploit JSON output"""
        client = ExploitDBClient()

        json_output = '''
        {
            "RESULTS_EXPLOIT": [
                {
                    "Title": "WordPress Plugin - SQL Injection",
                    "EDB-ID": "12345",
                    "Date": "2021-01-15",
                    "Author": "John Doe",
                    "Type": "webapps",
                    "Platform": "php",
                    "Path": "/usr/share/exploitdb/exploits/php/webapps/12345.txt"
                }
            ]
        }
        '''

        results = client._parse_output(json_output)

        assert len(results) == 1
        assert results[0]['id'] == 'EDB-12345'
        assert results[0]['title'] == "WordPress Plugin - SQL Injection"
        assert results[0]['source'] == 'exploitdb'
