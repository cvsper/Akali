"""Tests for main Fuzzer class."""

import pytest
import tempfile
import os
from pathlib import Path
from exploits.fuzzer.fuzzing import Fuzzer


class TestFuzzer:
    """Test suite for Fuzzer class."""

    @pytest.fixture
    def fuzzer(self):
        """Create a fuzzer instance."""
        return Fuzzer()

    @pytest.fixture
    def temp_dir(self):
        """Create a temporary directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            yield tmpdir

    @pytest.fixture
    def sample_corpus(self, temp_dir):
        """Create sample corpus files."""
        corpus_dir = Path(temp_dir) / "corpus"
        corpus_dir.mkdir()

        # Create some sample seed files
        (corpus_dir / "seed1.txt").write_text("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
        (corpus_dir / "seed2.txt").write_text("POST /api HTTP/1.1\r\nContent-Length: 10\r\n\r\ntest=value")
        (corpus_dir / "seed3.txt").write_bytes(b"\x00\x01\x02\x03\x04\x05")

        return str(corpus_dir)

    @pytest.fixture
    def vulnerable_binary(self, temp_dir):
        """Create a simple vulnerable C program for testing."""
        binary_path = Path(temp_dir) / "vuln.c"
        binary_path.write_text("""
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char buffer[64];
    if (argc > 1) {
        strcpy(buffer, argv[1]);  // Vulnerable to buffer overflow
        printf("Input: %s\\n", buffer);
    }
    return 0;
}
""")
        return str(binary_path)

    def test_fuzzer_initialization(self, fuzzer):
        """Test fuzzer initializes correctly."""
        assert fuzzer is not None
        assert hasattr(fuzzer, 'fuzz_binary')
        assert hasattr(fuzzer, 'fuzz_network')
        assert hasattr(fuzzer, 'analyze_crashes')
        assert hasattr(fuzzer, 'mutate_input')

    def test_mutate_input_basic(self, fuzzer):
        """Test basic input mutation."""
        seed = b"Hello World"
        mutations = fuzzer.mutate_input(seed, mutations=10)

        assert len(mutations) == 10
        assert all(isinstance(m, bytes) for m in mutations)
        # At least some mutations should be different from the seed
        assert any(m != seed for m in mutations)

    def test_mutate_input_strategies(self, fuzzer):
        """Test different mutation strategies are applied."""
        seed = b"AAAA"
        mutations = fuzzer.mutate_input(seed, mutations=100)

        # Should have various lengths due to different strategies
        lengths = set(len(m) for m in mutations)
        assert len(lengths) > 1, "Should have mutations of different lengths"

    def test_mutate_input_preserves_structure(self, fuzzer):
        """Test that some mutations preserve basic structure."""
        seed = b"GET / HTTP/1.1\r\n"
        mutations = fuzzer.mutate_input(seed, mutations=50)

        # At least some should still contain parts of the original
        assert any(b"GET" in m or b"HTTP" in m for m in mutations)

    def test_fuzz_binary_requires_valid_path(self, fuzzer):
        """Test that fuzz_binary validates binary path."""
        with pytest.raises((FileNotFoundError, ValueError)):
            fuzzer.fuzz_binary("/nonexistent/binary", "/tmp/corpus")

    def test_fuzz_binary_requires_corpus(self, fuzzer, temp_dir):
        """Test that fuzz_binary requires corpus directory."""
        binary_path = Path(temp_dir) / "test_binary"
        binary_path.write_text("#!/bin/bash\necho test")
        binary_path.chmod(0o755)

        with pytest.raises((FileNotFoundError, ValueError)):
            fuzzer.fuzz_binary(str(binary_path), "/nonexistent/corpus")

    def test_fuzz_binary_basic_execution(self, fuzzer, vulnerable_binary, sample_corpus, temp_dir):
        """Test basic binary fuzzing execution."""
        # Compile the vulnerable binary
        import subprocess
        binary_path = Path(temp_dir) / "vuln"
        try:
            subprocess.run(
                ["gcc", vulnerable_binary, "-o", str(binary_path)],
                check=True,
                capture_output=True,
                timeout=10
            )
        except (subprocess.CalledProcessError, FileNotFoundError):
            pytest.skip("GCC not available for compiling test binary")

        # Run fuzzer with very short timeout
        result = fuzzer.fuzz_binary(
            str(binary_path),
            sample_corpus,
            timeout=1  # 1 second timeout for testing
        )

        assert isinstance(result, dict)
        assert 'iterations' in result
        assert 'crashes' in result
        assert 'unique_crashes' in result
        assert 'status' in result

    def test_fuzz_network_basic(self, fuzzer):
        """Test network fuzzing basic functionality."""
        # Test with a mock target (won't actually connect in CI)
        result = fuzzer.fuzz_network(
            target="127.0.0.1",
            port=9999,
            protocol="tcp",
            iterations=10,
            timeout_per_request=0.1
        )

        assert isinstance(result, dict)
        assert 'iterations' in result
        assert 'anomalies' in result
        assert 'errors' in result

    def test_fuzz_network_protocols(self, fuzzer):
        """Test different network protocols."""
        protocols = ['tcp', 'udp', 'http']

        for protocol in protocols:
            result = fuzzer.fuzz_network(
                target="127.0.0.1",
                port=9999,
                protocol=protocol,
                iterations=5,
                timeout_per_request=0.1
            )
            assert result['protocol'] == protocol

    def test_analyze_crashes_empty_directory(self, fuzzer, temp_dir):
        """Test crash analysis with no crashes."""
        crash_dir = Path(temp_dir) / "crashes"
        crash_dir.mkdir()

        results = fuzzer.analyze_crashes(str(crash_dir))
        assert isinstance(results, list)
        assert len(results) == 0

    def test_analyze_crashes_with_files(self, fuzzer, temp_dir):
        """Test crash analysis with crash files."""
        crash_dir = Path(temp_dir) / "crashes"
        crash_dir.mkdir()

        # Create some mock crash files
        (crash_dir / "crash1.txt").write_bytes(b"A" * 100)
        (crash_dir / "crash2.txt").write_bytes(b"\x00" * 64 + b"B" * 50)

        results = fuzzer.analyze_crashes(str(crash_dir))
        assert isinstance(results, list)
        assert len(results) == 2

        for crash in results:
            assert 'file' in crash
            assert 'size' in crash
            assert 'hash' in crash

    def test_mutate_input_empty_seed(self, fuzzer):
        """Test mutation with empty seed."""
        seed = b""
        mutations = fuzzer.mutate_input(seed, mutations=10)

        assert len(mutations) == 10
        # Some mutations should add content to empty seed
        assert any(len(m) > 0 for m in mutations)

    def test_mutate_input_large_seed(self, fuzzer):
        """Test mutation with large seed."""
        seed = b"A" * 10000
        mutations = fuzzer.mutate_input(seed, mutations=10)

        assert len(mutations) == 10
        # Should handle large inputs
        assert all(isinstance(m, bytes) for m in mutations)

    def test_fuzz_binary_timeout_handling(self, fuzzer, sample_corpus):
        """Test that fuzzer respects timeout parameter."""
        import time

        # Create a simple script that just sleeps
        with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
            f.write("#!/bin/bash\nsleep 10\n")
            script_path = f.name

        os.chmod(script_path, 0o755)

        try:
            start = time.time()
            result = fuzzer.fuzz_binary(script_path, sample_corpus, timeout=2)
            elapsed = time.time() - start

            # Should terminate within reasonable time of timeout
            assert elapsed < 5, "Fuzzer should respect timeout"
            assert result['status'] in ['timeout', 'completed']
        finally:
            os.unlink(script_path)

    def test_fuzz_network_seed_corpus(self, fuzzer, sample_corpus):
        """Test network fuzzing with seed corpus."""
        result = fuzzer.fuzz_network(
            target="127.0.0.1",
            port=9999,
            protocol="tcp",
            iterations=10,
            corpus_dir=sample_corpus,
            timeout_per_request=0.1
        )

        assert 'corpus_used' in result
        assert result['corpus_used'] == True

    def test_crash_deduplication(self, fuzzer, temp_dir):
        """Test that crash analyzer deduplicates similar crashes."""
        crash_dir = Path(temp_dir) / "crashes"
        crash_dir.mkdir()

        # Create duplicate crashes
        crash_data = b"A" * 100
        (crash_dir / "crash1.txt").write_bytes(crash_data)
        (crash_dir / "crash2.txt").write_bytes(crash_data)
        (crash_dir / "crash3.txt").write_bytes(b"B" * 100)

        results = fuzzer.analyze_crashes(str(crash_dir))

        # Should identify duplicates by hash
        hashes = [r['hash'] for r in results]
        assert len(hashes) == 3
        assert len(set(hashes)) == 2  # Only 2 unique hashes
