"""Tests for PayloadBuilder."""

import pytest
from pathlib import Path
from exploits.generator.payload_builder import PayloadBuilder


class TestPayloadBuilder:
    """Test suite for PayloadBuilder."""

    def setup_method(self):
        """Setup test fixtures."""
        self.builder = PayloadBuilder()

    # Buffer Overflow Tests

    def test_generate_buffer_overflow_basic(self):
        """Test basic buffer overflow generation."""
        offset = 1024
        shellcode = b"\x90" * 100  # NOP sled

        payload = self.builder.generate_buffer_overflow(
            offset=offset,
            shellcode=shellcode
        )

        assert isinstance(payload, bytes)
        assert len(payload) >= offset
        assert shellcode in payload

    def test_generate_buffer_overflow_with_bad_chars(self):
        """Test buffer overflow with bad character filtering."""
        offset = 512
        shellcode = b"\x90\x00\x0a\x0d"  # Contains common bad chars
        bad_chars = [b"\x00", b"\x0a", b"\x0d"]

        payload = self.builder.generate_buffer_overflow(
            offset=offset,
            shellcode=shellcode,
            bad_chars=bad_chars
        )

        assert isinstance(payload, bytes)
        # Check bad chars are not in padding (except shellcode)
        for bad_char in bad_chars:
            # Bad chars might be in shellcode, but not in padding
            pass

    def test_generate_buffer_overflow_with_return_address(self):
        """Test buffer overflow with custom return address."""
        offset = 256
        shellcode = b"\x90" * 50
        ret_addr = b"\x41\x42\x43\x44"  # 0x44434241 (little-endian)

        payload = self.builder.generate_buffer_overflow(
            offset=offset,
            shellcode=shellcode,
            return_address=ret_addr
        )

        assert ret_addr in payload

    # SQL Injection Tests

    def test_generate_sql_injection_mysql_union(self):
        """Test MySQL UNION-based SQLi generation."""
        payloads = self.builder.generate_sql_injection(
            target_db="mysql",
            payload_type="union"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0
        assert any("UNION" in p.upper() for p in payloads)
        assert any("SELECT" in p.upper() for p in payloads)

    def test_generate_sql_injection_mysql_blind(self):
        """Test MySQL blind SQLi generation."""
        payloads = self.builder.generate_sql_injection(
            target_db="mysql",
            payload_type="blind"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0
        assert any("SLEEP" in p.upper() or "BENCHMARK" in p.upper() for p in payloads)

    def test_generate_sql_injection_postgresql(self):
        """Test PostgreSQL SQLi generation."""
        payloads = self.builder.generate_sql_injection(
            target_db="postgresql",
            payload_type="union"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0
        # PostgreSQL specific syntax
        assert any("pg_" in p.lower() or "::" in p for p in payloads)

    def test_generate_sql_injection_error_based(self):
        """Test error-based SQLi generation."""
        payloads = self.builder.generate_sql_injection(
            target_db="mysql",
            payload_type="error"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0

    # XSS Tests

    def test_generate_xss_script_context(self):
        """Test XSS payloads for script context."""
        payloads = self.builder.generate_xss(
            context="script",
            payload_type="reflected"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0
        assert any("<script>" in p.lower() for p in payloads)

    def test_generate_xss_html_context(self):
        """Test XSS payloads for HTML context."""
        payloads = self.builder.generate_xss(
            context="html",
            payload_type="reflected"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0
        # Should contain various HTML injection attempts
        assert any("<" in p and ">" in p for p in payloads)

    def test_generate_xss_attribute_context(self):
        """Test XSS payloads for attribute context."""
        payloads = self.builder.generate_xss(
            context="attribute",
            payload_type="reflected"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0
        # Should contain attribute breakout attempts
        assert any('"' in p or "'" in p for p in payloads)

    def test_generate_xss_dom_based(self):
        """Test DOM-based XSS payloads."""
        payloads = self.builder.generate_xss(
            context="script",
            payload_type="dom"
        )

        assert isinstance(payloads, list)
        assert len(payloads) > 0

    # ROP Chain Tests

    def test_generate_rop_chain_basic(self):
        """Test basic ROP chain generation."""
        # Create a minimal test binary (will be mocked in real implementation)
        test_binary = Path("/tmp/test_binary")

        # For now, test that it returns bytes or raises appropriate error
        try:
            rop_chain = self.builder.generate_rop_chain(str(test_binary))
            assert isinstance(rop_chain, bytes) or rop_chain is None
        except FileNotFoundError:
            # Expected if binary doesn't exist
            pass
        except ImportError:
            # Expected if pwntools not installed
            pass

    # Encoding Tests

    def test_encode_payload_url(self):
        """Test URL encoding of payloads."""
        payload = "<script>alert(1)</script>"
        encoded = self.builder.encode_payload(payload, encoding="url")

        assert isinstance(encoded, str)
        assert "%3C" in encoded or "%3c" in encoded  # URL-encoded '<'
        assert "script" in encoded

    def test_encode_payload_base64(self):
        """Test Base64 encoding of payloads."""
        payload = "test payload"
        encoded = self.builder.encode_payload(payload, encoding="base64")

        assert isinstance(encoded, str)
        assert encoded != payload
        # Base64 should be decodable
        import base64
        decoded = base64.b64decode(encoded).decode()
        assert decoded == payload

    def test_encode_payload_hex(self):
        """Test hex encoding of payloads."""
        payload = "ABC"
        encoded = self.builder.encode_payload(payload, encoding="hex")

        assert isinstance(encoded, str)
        assert all(c in "0123456789abcdefABCDEF" for c in encoded)

    def test_encode_payload_double_url(self):
        """Test double URL encoding."""
        payload = "<script>"
        encoded = self.builder.encode_payload(payload, encoding="double-url")

        assert isinstance(encoded, str)
        assert "%25" in encoded  # Double-encoded

    # Template Tests

    def test_load_template(self):
        """Test loading payload templates."""
        # Should load from templates directory
        try:
            template = self.builder.load_template("sqli_mysql.txt")
            assert isinstance(template, str) or isinstance(template, list)
        except FileNotFoundError:
            # Expected if template doesn't exist yet
            pass

    # Bad Character Filter Tests

    def test_filter_bad_chars(self):
        """Test bad character filtering."""
        payload = b"\x00\x01\x02\x03\x04"
        bad_chars = [b"\x00", b"\x02"]

        filtered = self.builder.filter_bad_chars(payload, bad_chars)

        assert b"\x00" not in filtered
        assert b"\x02" not in filtered
        assert b"\x01" in filtered
        assert b"\x03" in filtered

    # Integration Tests

    def test_generate_multiple_payloads(self):
        """Test generating multiple payload types."""
        # SQLi
        sqli_payloads = self.builder.generate_sql_injection("mysql", "union")
        assert len(sqli_payloads) > 0

        # XSS
        xss_payloads = self.builder.generate_xss("script", "reflected")
        assert len(xss_payloads) > 0

        # Buffer overflow
        bof_payload = self.builder.generate_buffer_overflow(1024, b"\x90" * 100)
        assert len(bof_payload) > 0

    def test_payload_metadata(self):
        """Test that payloads include metadata."""
        payloads = self.builder.generate_sql_injection(
            target_db="mysql",
            payload_type="union",
            include_metadata=True
        )

        # If metadata is supported, check structure
        if payloads and isinstance(payloads[0], dict):
            assert "payload" in payloads[0]
            assert "description" in payloads[0] or "type" in payloads[0]


class TestPayloadVariants:
    """Test payload variant generation."""

    def setup_method(self):
        """Setup test fixtures."""
        self.builder = PayloadBuilder()

    def test_generate_sqli_variants(self):
        """Test generating SQLi variants with different encodings."""
        base_payloads = self.builder.generate_sql_injection("mysql", "union")

        variants = []
        for payload in base_payloads[:3]:  # Test first 3
            variants.append(self.builder.encode_payload(payload, "url"))
            variants.append(self.builder.encode_payload(payload, "base64"))

        assert len(variants) > 0
        assert len(set(variants)) == len(variants)  # All unique

    def test_generate_xss_variants(self):
        """Test generating XSS variants with different contexts."""
        contexts = ["script", "html", "attribute"]

        all_payloads = []
        for context in contexts:
            payloads = self.builder.generate_xss(context, "reflected")
            all_payloads.extend(payloads)

        assert len(all_payloads) > len(contexts)  # Multiple payloads per context


class TestBufferOverflowBuilder:
    """Test buffer overflow specific functionality."""

    def setup_method(self):
        """Setup test fixtures."""
        self.builder = PayloadBuilder()

    def test_pattern_generation(self):
        """Test cyclic pattern generation for offset finding."""
        pattern = self.builder.generate_pattern(1000)

        assert isinstance(pattern, bytes)
        assert len(pattern) == 1000
        # Pattern should be unique (for offset finding)
        # Check first 8 bytes differ from next 8 bytes
        assert pattern[:8] != pattern[8:16]

    def test_pattern_offset(self):
        """Test finding offset in cyclic pattern."""
        pattern = self.builder.generate_pattern(1000)

        # Find offset of a substring
        offset = self.builder.find_pattern_offset(pattern[100:104], pattern)

        assert offset == 100

    def test_shellcode_encoding(self):
        """Test shellcode encoding to avoid bad chars."""
        shellcode = b"\x00\x01\x02\x03"
        bad_chars = [b"\x00"]

        # Should encode or return None if impossible
        result = self.builder.encode_shellcode(shellcode, bad_chars)

        if result:
            assert b"\x00" not in result
