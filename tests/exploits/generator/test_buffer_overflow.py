"""Tests for Buffer Overflow Generator."""

import pytest
from exploits.generator.buffer_overflow import BufferOverflowGenerator


class TestBufferOverflowGenerator:
    """Test suite for BufferOverflowGenerator."""

    def setup_method(self):
        """Setup test fixtures."""
        self.generator = BufferOverflowGenerator()

    def test_generate_basic_overflow(self):
        """Test basic buffer overflow generation."""
        payload = self.generator.generate(
            offset=1024,
            shellcode=b"\x90" * 100,
            return_address=b"\x41\x42\x43\x44"
        )

        assert isinstance(payload, bytes)
        assert len(payload) >= 1024
        assert b"\x41\x42\x43\x44" in payload

    def test_generate_with_nop_sled(self):
        """Test generation with NOP sled."""
        shellcode = b"\xcc" * 10  # INT3 instructions
        payload = self.generator.generate(
            offset=512,
            shellcode=shellcode,
            nop_sled_size=100
        )

        assert b"\x90" * 100 in payload or b"\x90" in payload

    def test_filter_bad_characters(self):
        """Test bad character filtering."""
        bad_chars = [b"\x00", b"\x0a", b"\x0d"]
        payload = self.generator.generate(
            offset=256,
            shellcode=b"\x90" * 50,
            bad_chars=bad_chars
        )

        # Check that bad chars are avoided in padding
        padding_end = 256 - 50
        padding = payload[:padding_end]

        for bad_char in bad_chars:
            # Allow in shellcode, but not in padding
            if bad_char != b"\x90":  # NOP is okay
                assert bad_char not in padding or bad_char == b"\x90"

    def test_generate_cyclic_pattern(self):
        """Test cyclic pattern generation for offset discovery."""
        pattern = self.generator.generate_pattern(1000)

        assert isinstance(pattern, bytes)
        assert len(pattern) == 1000

        # Pattern should be unique - check distinctness
        chunks = [pattern[i:i+4] for i in range(0, min(100, len(pattern)), 4)]
        assert len(set(chunks)) > 10  # Should have many unique chunks

    def test_find_offset_in_pattern(self):
        """Test finding offset in cyclic pattern."""
        pattern = self.generator.generate_pattern(2000)

        # Extract a 4-byte sequence from position 100
        sequence = pattern[100:104]

        # Find it
        offset = self.generator.find_offset(sequence)

        assert offset == 100

    def test_generate_with_custom_padding(self):
        """Test generation with custom padding character."""
        payload = self.generator.generate(
            offset=512,
            shellcode=b"\xcc" * 10,
            padding_char=b"\x41"  # 'A' character
        )

        assert b"\x41" in payload

    def test_shellcode_validation(self):
        """Test shellcode validation."""
        # Valid shellcode
        valid = b"\x90\x90\x90"
        assert self.generator.validate_shellcode(valid) == True

        # Shellcode with bad chars should be detected
        bad_chars = [b"\x00"]
        invalid = b"\x90\x00\x90"
        assert self.generator.validate_shellcode(invalid, bad_chars) == False

    def test_reverse_endian(self):
        """Test endianness conversion for return addresses."""
        # Little-endian to big-endian
        addr = b"\x01\x02\x03\x04"
        reversed_addr = self.generator.reverse_endian(addr)

        assert reversed_addr == b"\x04\x03\x02\x01"

    def test_generate_ret_sled(self):
        """Test RET sled generation (for chaining)."""
        ret_sled = self.generator.generate_ret_sled(size=20)

        assert isinstance(ret_sled, bytes)
        assert len(ret_sled) == 20
        assert b"\xc3" in ret_sled  # RET instruction

    def test_align_shellcode(self):
        """Test shellcode alignment."""
        shellcode = b"\x90" * 15
        aligned = self.generator.align_shellcode(shellcode, alignment=16)

        assert len(aligned) % 16 == 0
        assert shellcode in aligned

    def test_generate_egghunter(self):
        """Test egghunter generation for limited space."""
        egghunter = self.generator.generate_egghunter(tag=b"w00t")

        assert isinstance(egghunter, bytes)
        assert len(egghunter) < 50  # Egghunters are small
        assert b"w00t" in egghunter or b"w00tw00t" in egghunter
