"""Tests for service exploitation module."""

import pytest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
import sys

sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from extended.privesc.exploit_service import ServiceExploiter


class TestServiceExploiter:
    """Test suite for ServiceExploiter class."""

    @pytest.fixture
    def exploiter(self):
        """Create ServiceExploiter instance."""
        return ServiceExploiter()

    def test_init(self, exploiter):
        """Test initialization."""
        assert exploiter is not None

    @patch('subprocess.run')
    def test_exploit_unquoted_service_path(self, mock_run, exploiter):
        """Test unquoted service path exploitation."""
        mock_run.return_value = Mock(returncode=0, stdout='')

        result = exploiter.exploit_unquoted_service_path(
            'VulnerableService',
            'C:\\Program Files\\Vulnerable App\\service.exe',
            'C:\\payload.exe'
        )

        assert 'success' in result
        assert 'message' in result
        assert isinstance(result['success'], bool)

    @patch('subprocess.run')
    def test_exploit_weak_permissions(self, mock_run, exploiter):
        """Test weak service permission exploitation."""
        mock_run.return_value = Mock(returncode=0, stdout='')

        result = exploiter.exploit_weak_permissions(
            'VulnerableService',
            'C:\\payload.exe'
        )

        assert 'success' in result
        assert 'steps' in result

    @patch('subprocess.run')
    def test_exploit_dll_hijacking(self, mock_run, exploiter):
        """Test DLL hijacking exploitation."""
        result = exploiter.exploit_dll_hijacking(
            'C:\\Program Files\\App\\app.exe',
            'missing.dll',
            'C:\\evil.dll'
        )

        assert 'success' in result
        assert 'message' in result

    def test_verify_service_writable(self, exploiter):
        """Test service write permission verification."""
        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(
                returncode=0,
                stdout='SERVICE_CHANGE_CONFIG\nSERVICE_ALL_ACCESS\n'
            )

            result = exploiter._verify_service_writable('TestService')
            assert isinstance(result, bool)

    def test_backup_service_binary(self, exploiter):
        """Test service binary backup."""
        with patch('shutil.copy2') as mock_copy:
            result = exploiter._backup_service_binary('C:\\service.exe')
            assert isinstance(result, bool)

    def test_restore_service_binary(self, exploiter):
        """Test service binary restoration."""
        with patch('shutil.move') as mock_move:
            result = exploiter._restore_service_binary('C:\\service.exe')
            assert isinstance(result, bool)

    @patch('subprocess.run')
    def test_stop_service(self, mock_run, exploiter):
        """Test service stop."""
        mock_run.return_value = Mock(returncode=0)

        result = exploiter._stop_service('TestService')
        assert isinstance(result, bool)

    @patch('subprocess.run')
    def test_start_service(self, mock_run, exploiter):
        """Test service start."""
        mock_run.return_value = Mock(returncode=0)

        result = exploiter._start_service('TestService')
        assert isinstance(result, bool)

    def test_calculate_exploit_paths(self, exploiter):
        """Test exploit path calculation for unquoted paths."""
        service_path = 'C:\\Program Files\\Vulnerable App\\service.exe'
        paths = exploiter._calculate_exploit_paths(service_path)

        assert isinstance(paths, list)
        assert len(paths) > 0
        assert all('\\' in path for path in paths)

    def test_is_path_writable(self, exploiter):
        """Test path write permission check."""
        with patch('os.access', return_value=True):
            assert exploiter._is_path_writable('C:\\test') is True

    def test_generate_exploit_payload(self, exploiter):
        """Test exploit payload generation."""
        result = exploiter._generate_exploit_payload(
            'reverse_shell',
            '192.168.1.100',
            4444
        )

        assert isinstance(result, str)
        assert len(result) > 0

    @patch('subprocess.run')
    def test_exploit_registry_autorun(self, mock_run, exploiter):
        """Test registry autorun exploitation."""
        mock_run.return_value = Mock(returncode=0)

        result = exploiter.exploit_registry_autorun(
            'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
            'TestApp',
            'C:\\payload.exe'
        )

        assert 'success' in result

    @patch('subprocess.run')
    def test_exploit_scheduled_task(self, mock_run, exploiter):
        """Test scheduled task exploitation."""
        mock_run.return_value = Mock(returncode=0)

        result = exploiter.exploit_scheduled_task(
            'VulnerableTask',
            'C:\\payload.exe'
        )

        assert 'success' in result
        assert 'message' in result
