"""ROP Chain Generator."""

import struct
import subprocess
from pathlib import Path
from typing import List, Optional, Dict, Any


class ROPGenerator:
    """Generate ROP chains for binary exploitation."""

    def __init__(self):
        """Initialize generator."""
        self.pwntools_available = self._check_pwntools()
        self.ropgadget_available = self._check_ropgadget()

    def _check_pwntools(self) -> bool:
        """Check if pwntools is available."""
        try:
            import pwn
            return True
        except ImportError:
            return False

    def _check_ropgadget(self) -> bool:
        """Check if ROPgadget is available."""
        try:
            result = subprocess.run(
                ["ROPgadget", "--version"],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def generate_chain(
        self,
        binary_path: str,
        goal: str = "shell"
    ) -> Optional[bytes]:
        """Generate ROP chain for binary.

        Args:
            binary_path: Path to target binary
            goal: Goal (shell, arbitrary_write, leak, etc.)

        Returns:
            ROP chain bytes or None if generation fails
        """
        if not Path(binary_path).exists():
            raise FileNotFoundError(f"Binary not found: {binary_path}")

        if not self.pwntools_available:
            # Fallback to basic implementation
            return self._generate_basic_chain(binary_path, goal)

        try:
            if goal == "shell":
                return self.build_execve_chain(binary_path)
            elif goal == "system":
                return self.build_system_chain(binary_path)
            else:
                return self._generate_basic_chain(binary_path, goal)
        except Exception as e:
            return None

    def find_gadgets(
        self,
        binary_path: str,
        max_gadgets: int = 100
    ) -> List[Dict[str, Any]]:
        """Find ROP gadgets in binary.

        Args:
            binary_path: Path to binary
            max_gadgets: Maximum gadgets to return

        Returns:
            List of gadget dicts with 'address' and 'instructions'
        """
        if not self.ropgadget_available:
            return []

        try:
            result = subprocess.run(
                ["ROPgadget", "--binary", binary_path, "--depth", "10"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                return []

            # Parse output
            gadgets = []
            for line in result.stdout.split("\n"):
                if ":" in line and "; ret" in line:
                    parts = line.split(":")
                    if len(parts) >= 2:
                        addr_str = parts[0].strip()
                        instructions = parts[1].strip()

                        try:
                            address = int(addr_str, 16)
                            gadgets.append({
                                "address": address,
                                "instructions": instructions
                            })
                        except ValueError:
                            continue

                if len(gadgets) >= max_gadgets:
                    break

            return gadgets
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return []

    def build_execve_chain(
        self,
        binary_path: str,
        command: str = "/bin/sh"
    ) -> Optional[bytes]:
        """Build execve() ROP chain.

        Args:
            binary_path: Path to binary
            command: Command to execute

        Returns:
            ROP chain or None
        """
        if not self.pwntools_available:
            return None

        try:
            from pwn import ELF, ROP, p64, p32

            elf = ELF(binary_path, checksec=False)
            rop = ROP(elf)

            # Try to build execve chain
            # This requires finding gadgets for:
            # execve("/bin/sh", NULL, NULL)
            # RAX = 59 (execve syscall)
            # RDI = pointer to "/bin/sh"
            # RSI = NULL
            # RDX = NULL

            # For simplicity, return None (full implementation is complex)
            return None
        except Exception:
            return None

    def build_system_chain(
        self,
        binary_path: str,
        command: str = "ls"
    ) -> Optional[bytes]:
        """Build system() ROP chain.

        Args:
            binary_path: Path to binary
            command: Command to pass to system()

        Returns:
            ROP chain or None
        """
        if not self.pwntools_available:
            return None

        try:
            from pwn import ELF, ROP

            elf = ELF(binary_path, checksec=False)
            rop = ROP(elf)

            # Try to call system()
            # This is simplified - real implementation needs to:
            # 1. Find system() in PLT or libc
            # 2. Find writable area for command string
            # 3. Build chain to call system(command)

            return None
        except Exception:
            return None

    def find_libc_base(self, binary_path: str) -> Optional[int]:
        """Find libc base address.

        Note: This is for static analysis. Runtime ASLR will change it.

        Args:
            binary_path: Path to binary

        Returns:
            Libc base address or None
        """
        if not self.pwntools_available:
            return None

        try:
            from pwn import ELF

            elf = ELF(binary_path, checksec=False)

            # Get libc
            if hasattr(elf, 'libc') and elf.libc:
                return elf.libc.address

            return None
        except Exception:
            return None

    def find_pop_pop_ret(self, binary_path: str) -> Optional[int]:
        """Find pop-pop-ret gadget.

        Args:
            binary_path: Path to binary

        Returns:
            Gadget address or None
        """
        gadgets = self.find_gadgets(binary_path)

        for gadget in gadgets:
            instructions = gadget["instructions"].lower()
            if "pop" in instructions and instructions.count("pop") >= 2 and "ret" in instructions:
                return gadget["address"]

        return None

    def build_mprotect_chain(
        self,
        binary_path: str,
        address: int,
        size: int
    ) -> Optional[bytes]:
        """Build mprotect() ROP chain for DEP bypass.

        Args:
            binary_path: Path to binary
            address: Memory address to make executable
            size: Size of memory region

        Returns:
            ROP chain or None
        """
        # This is advanced - requires finding mprotect in PLT
        # and building chain to call it with correct arguments
        return None

    def build_manual_chain(self, gadgets: List[Dict[str, Any]]) -> bytes:
        """Build ROP chain from manual gadget list.

        Args:
            gadgets: List of gadget dicts with 'address'

        Returns:
            ROP chain bytes
        """
        chain = b""

        for gadget in gadgets:
            addr = gadget["address"]
            # Pack as little-endian 64-bit (adjust for 32-bit if needed)
            try:
                chain += struct.pack("<Q", addr)  # 64-bit
            except struct.error:
                chain += struct.pack("<I", addr)  # 32-bit

        return chain

    def check_protections(self, binary_path: str) -> Dict[str, bool]:
        """Check binary protections.

        Args:
            binary_path: Path to binary

        Returns:
            Dict of protection states
        """
        protections = {
            "nx": False,
            "pie": False,
            "canary": False,
            "relro": False,
        }

        if self.pwntools_available:
            try:
                from pwn import ELF

                elf = ELF(binary_path, checksec=False)
                protections["nx"] = elf.nx
                protections["pie"] = elf.pie
                protections["canary"] = elf.canary
                protections["relro"] = elf.relro != "No"

                return protections
            except Exception:
                pass

        # Fallback: use checksec if available
        try:
            result = subprocess.run(
                ["checksec", "--file", binary_path],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                output = result.stdout.lower()
                protections["nx"] = "nx enabled" in output
                protections["pie"] = "pie enabled" in output
                protections["canary"] = "canary found" in output
                protections["relro"] = "full relro" in output or "partial relro" in output
        except (FileNotFoundError, subprocess.TimeoutExpired):
            pass

        return protections

    def find_plt_entries(self, binary_path: str) -> Dict[str, int]:
        """Find PLT entries in binary.

        Args:
            binary_path: Path to binary

        Returns:
            Dict mapping function names to PLT addresses
        """
        if not self.pwntools_available:
            return {}

        try:
            from pwn import ELF

            elf = ELF(binary_path, checksec=False)
            plt = {}

            for name, addr in elf.plt.items():
                plt[name] = addr

            return plt
        except Exception:
            return {}

    def find_got_entries(self, binary_path: str) -> Dict[str, int]:
        """Find GOT entries in binary.

        Args:
            binary_path: Path to binary

        Returns:
            Dict mapping function names to GOT addresses
        """
        if not self.pwntools_available:
            return {}

        try:
            from pwn import ELF

            elf = ELF(binary_path, checksec=False)
            got = {}

            for name, addr in elf.got.items():
                got[name] = addr

            return got
        except Exception:
            return {}

    def _generate_basic_chain(self, binary_path: str, goal: str) -> Optional[bytes]:
        """Generate basic ROP chain without pwntools.

        Args:
            binary_path: Path to binary
            goal: Goal type

        Returns:
            Basic ROP chain or None
        """
        # Find gadgets using ROPgadget if available
        gadgets = self.find_gadgets(binary_path, max_gadgets=50)

        if not gadgets:
            return None

        # Build a simple chain (example: just chain a few gadgets)
        chain = b""
        for gadget in gadgets[:5]:
            try:
                chain += struct.pack("<Q", gadget["address"])
            except struct.error:
                chain += struct.pack("<I", gadget["address"])

        return chain if len(chain) > 0 else None
