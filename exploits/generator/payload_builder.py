"""Main PayloadBuilder class for coordinating exploit generation."""

import base64
import urllib.parse
from pathlib import Path
from typing import List, Optional, Union

from .buffer_overflow import BufferOverflowGenerator
from .sqli import SQLiGenerator
from .xss import XSSGenerator
from .rop import ROPGenerator


class PayloadBuilder:
    """Unified interface for generating various exploit payloads."""

    def __init__(self):
        """Initialize payload generators."""
        self.bof_gen = BufferOverflowGenerator()
        self.sqli_gen = SQLiGenerator()
        self.xss_gen = XSSGenerator()
        self.rop_gen = ROPGenerator()

        self.templates_dir = Path(__file__).parent / "templates"

    # Buffer Overflow Methods

    def generate_buffer_overflow(
        self,
        offset: int,
        shellcode: Union[str, bytes],
        bad_chars: Optional[List[bytes]] = None,
        return_address: Optional[bytes] = None,
        nop_sled_size: int = 100,
        padding_char: bytes = b"A"
    ) -> bytes:
        """Generate buffer overflow exploit.

        Args:
            offset: Offset to return address
            shellcode: Shellcode to inject (string or bytes)
            bad_chars: List of bad characters to avoid
            return_address: Custom return address (4 bytes, little-endian)
            nop_sled_size: Size of NOP sled before shellcode
            padding_char: Character to use for padding

        Returns:
            Complete buffer overflow payload
        """
        # Convert shellcode to bytes if needed
        if isinstance(shellcode, str):
            shellcode = shellcode.encode()

        return self.bof_gen.generate(
            offset=offset,
            shellcode=shellcode,
            bad_chars=bad_chars,
            return_address=return_address,
            nop_sled_size=nop_sled_size,
            padding_char=padding_char
        )

    def generate_pattern(self, size: int) -> bytes:
        """Generate cyclic pattern for offset finding.

        Args:
            size: Pattern size

        Returns:
            Cyclic pattern
        """
        return self.bof_gen.generate_pattern(size)

    def find_pattern_offset(self, sequence: bytes, pattern: Optional[bytes] = None) -> int:
        """Find offset of sequence in pattern.

        Args:
            sequence: 4-byte sequence to find
            pattern: Pattern to search (or None to use default)

        Returns:
            Offset in pattern, or -1 if not found
        """
        if pattern is None:
            pattern = self.bof_gen.generate_pattern(10000)

        return self.bof_gen.find_offset(sequence)

    def filter_bad_chars(self, payload: bytes, bad_chars: List[bytes]) -> bytes:
        """Filter bad characters from payload.

        Args:
            payload: Original payload
            bad_chars: List of bad characters

        Returns:
            Filtered payload
        """
        return self.bof_gen.filter_bad_chars(payload, bad_chars)

    def encode_shellcode(
        self,
        shellcode: bytes,
        bad_chars: List[bytes]
    ) -> Optional[bytes]:
        """Encode shellcode to avoid bad characters.

        Args:
            shellcode: Original shellcode
            bad_chars: Bad characters to avoid

        Returns:
            Encoded shellcode or None if impossible
        """
        return self.bof_gen.encode_shellcode(shellcode, bad_chars)

    def validate_shellcode(
        self,
        shellcode: bytes,
        bad_chars: Optional[List[bytes]] = None
    ) -> bool:
        """Validate shellcode against bad characters.

        Args:
            shellcode: Shellcode to validate
            bad_chars: Bad characters to check

        Returns:
            True if shellcode is valid
        """
        return self.bof_gen.validate_shellcode(shellcode, bad_chars)

    # SQL Injection Methods

    def generate_sql_injection(
        self,
        target_db: str,
        payload_type: str,
        include_metadata: bool = False
    ) -> List[Union[str, dict]]:
        """Generate SQL injection payloads.

        Args:
            target_db: Database type (mysql, postgresql, mssql, oracle)
            payload_type: Payload type (union, blind, error, stacked)
            include_metadata: Include metadata dict for each payload

        Returns:
            List of SQL injection payloads
        """
        return self.sqli_gen.generate(target_db, payload_type, include_metadata)

    # XSS Methods

    def generate_xss(
        self,
        context: str,
        payload_type: str,
        filter_evasion: bool = False
    ) -> List[str]:
        """Generate XSS payloads.

        Args:
            context: Context (script, html, attribute, url)
            payload_type: Type (reflected, stored, dom)
            filter_evasion: Enable filter evasion techniques

        Returns:
            List of XSS payloads
        """
        return self.xss_gen.generate(context, payload_type, filter_evasion)

    # ROP Chain Methods

    def generate_rop_chain(self, binary_path: str) -> Optional[bytes]:
        """Build ROP chain for binary.

        Args:
            binary_path: Path to target binary

        Returns:
            ROP chain bytes or None if generation fails
        """
        return self.rop_gen.generate_chain(binary_path)

    # Encoding Methods

    def encode_payload(self, payload: str, encoding: str) -> str:
        """Encode payload with specified encoding.

        Args:
            payload: Payload string
            encoding: Encoding type (url, base64, hex, double-url)

        Returns:
            Encoded payload
        """
        if encoding == "url":
            return urllib.parse.quote(payload)
        elif encoding == "double-url":
            return urllib.parse.quote(urllib.parse.quote(payload))
        elif encoding == "base64":
            return base64.b64encode(payload.encode()).decode()
        elif encoding == "hex":
            return "".join(f"{ord(c):02x}" for c in payload)
        else:
            raise ValueError(f"Unknown encoding: {encoding}")

    # Template Methods

    def load_template(self, template_name: str) -> Union[str, List[str]]:
        """Load payload template from file.

        Args:
            template_name: Template filename

        Returns:
            Template content as string or list of payloads

        Raises:
            FileNotFoundError: If template doesn't exist
        """
        template_path = self.templates_dir / template_name

        if not template_path.exists():
            raise FileNotFoundError(f"Template not found: {template_name}")

        with open(template_path, "r") as f:
            content = f.read()

        # Parse template - extract non-comment, non-empty lines
        payloads = []
        for line in content.split("\n"):
            line = line.strip()
            if line and not line.startswith("#"):
                payloads.append(line)

        # Return list if multiple payloads, otherwise return string
        return payloads if len(payloads) > 1 else (payloads[0] if payloads else "")
