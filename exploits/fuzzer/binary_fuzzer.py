"""Binary fuzzing with AFL++ and Python fallback."""

import os
import random
import subprocess
import time
import hashlib
from pathlib import Path
from typing import Dict, List, Optional


class BinaryFuzzer:
    """Binary application fuzzer with AFL++ and Python implementations."""

    def __init__(self):
        """Initialize binary fuzzer."""
        self.afl_available = self.check_afl_available()

    def check_afl_available(self) -> bool:
        """Check if AFL++ is installed and available.

        Returns:
            True if AFL++ is available, False otherwise
        """
        try:
            result = subprocess.run(
                ['which', 'afl-fuzz'],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def fuzz_with_afl(
        self,
        binary_path: str,
        corpus_dir: str,
        timeout: int = 3600
    ) -> Dict:
        """Fuzz binary using AFL++.

        Args:
            binary_path: Path to binary to fuzz
            corpus_dir: Directory with seed inputs
            timeout: Fuzzing timeout in seconds

        Returns:
            Dictionary with fuzzing results
        """
        output_dir = Path(binary_path).parent / "afl_output"
        output_dir.mkdir(exist_ok=True)

        cmd = self.build_afl_command(binary_path, corpus_dir, str(output_dir), timeout)

        start_time = time.time()
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )

            # Wait for timeout or completion
            process.wait(timeout=timeout)

        except subprocess.TimeoutExpired:
            process.kill()

        elapsed = time.time() - start_time

        # Parse AFL++ output
        crashes_dir = output_dir / "crashes"
        crashes = list(crashes_dir.glob('*')) if crashes_dir.exists() else []

        return {
            'method': 'afl',
            'iterations': self._parse_afl_iterations(output_dir),
            'crashes': len(crashes),
            'unique_crashes': len(set(self._hash_file(f) for f in crashes if f.is_file())),
            'elapsed_time': elapsed,
            'status': 'timeout' if elapsed >= timeout else 'completed',
            'crash_dir': str(crashes_dir) if crashes_dir.exists() else None
        }

    def fuzz_with_python(
        self,
        binary_path: str,
        corpus_dir: str,
        timeout: int = 3600
    ) -> Dict:
        """Fuzz binary using Python-based mutation fuzzer.

        Args:
            binary_path: Path to binary to fuzz
            corpus_dir: Directory with seed inputs
            timeout: Fuzzing timeout in seconds

        Returns:
            Dictionary with fuzzing results
        """
        corpus_path = Path(corpus_dir)

        # Load seed corpus
        seeds = []
        for seed_file in corpus_path.glob('*'):
            if seed_file.is_file():
                seeds.append(seed_file.read_bytes())

        # If no seeds, create default ones
        if not seeds:
            seeds = [
                b"A" * 10,
                b"test",
                b"\x00\x01\x02\x03",
                b"GET / HTTP/1.1\r\n\r\n"
            ]

        # Fuzzing loop
        crash_dir = Path(binary_path).parent / "crashes"
        crash_dir.mkdir(exist_ok=True)

        iterations = 0
        crashes = []
        unique_crashes = set()
        start_time = time.time()

        while time.time() - start_time < timeout:
            # Select random seed
            seed = random.choice(seeds)

            # Mutate it
            mutated = self._mutate(seed)

            # Run binary with mutated input
            crash_info = self._run_binary(binary_path, mutated)

            if crash_info:
                crash_hash = hashlib.md5(mutated).hexdigest()
                if crash_hash not in unique_crashes:
                    unique_crashes.add(crash_hash)
                    self.save_crash(mutated, str(crash_dir), f"crash_{crash_hash[:8]}")
                crashes.append(crash_info)

            iterations += 1

            # Quick iterations for testing
            if timeout < 5 and iterations > 50:
                break

        elapsed = time.time() - start_time

        return {
            'method': 'python',
            'iterations': iterations,
            'crashes': len(crashes),
            'unique_crashes': len(unique_crashes),
            'elapsed_time': elapsed,
            'status': 'timeout' if elapsed >= timeout else 'completed',
            'crash_dir': str(crash_dir)
        }

    def _run_binary(self, binary_path: str, input_data: bytes) -> Optional[Dict]:
        """Run binary with input and detect crashes.

        Args:
            binary_path: Path to binary
            input_data: Input data to pass to binary

        Returns:
            Crash info dict if crashed, None otherwise
        """
        try:
            process = subprocess.run(
                [binary_path],
                input=input_data,
                capture_output=True,
                timeout=1
            )

            return self.detect_crash(process.returncode, process.stdout, process.stderr)

        except subprocess.TimeoutExpired:
            return {'type': 'hang', 'signal': 'timeout'}
        except Exception:
            return None

    def detect_crash(self, returncode: int, stdout: bytes, stderr: bytes) -> Optional[Dict]:
        """Detect if execution resulted in a crash.

        Args:
            returncode: Process return code
            stdout: Process stdout
            stderr: Process stderr

        Returns:
            Crash info if crashed, None otherwise
        """
        # Typical crash signals on Unix
        crash_signals = {
            -11: 'SIGSEGV',  # Segmentation fault
            -6: 'SIGABRT',    # Abort
            -4: 'SIGILL',     # Illegal instruction
            -8: 'SIGFPE',     # Floating point exception
            -7: 'SIGBUS',     # Bus error
            139: 'SIGSEGV',   # Alternative SIGSEGV code
            134: 'SIGABRT',   # Alternative SIGABRT code
        }

        if returncode in crash_signals:
            return {
                'type': 'crash',
                'signal': crash_signals[returncode],
                'returncode': returncode
            }

        # Check for crash indicators in stderr
        crash_keywords = [b'segmentation fault', b'core dumped', b'abort', b'signal']
        if any(keyword in stderr.lower() for keyword in crash_keywords):
            return {
                'type': 'crash',
                'signal': 'detected_in_stderr',
                'returncode': returncode
            }

        return None

    def _mutate(self, data: bytes) -> bytes:
        """Apply random mutation to data.

        Args:
            data: Input data to mutate

        Returns:
            Mutated data
        """
        strategies = [
            self.mutate_bit_flip,
            self.mutate_byte_flip,
            self.mutate_byte_insert,
            self.mutate_byte_delete,
            self.mutate_interesting_values,
            self.mutate_chunk
        ]

        strategy = random.choice(strategies)
        return strategy(data)

    def mutate_bit_flip(self, data: bytes) -> bytes:
        """Flip random bits."""
        if not data:
            return data

        data_list = bytearray(data)
        byte_idx = random.randint(0, len(data_list) - 1)
        bit_idx = random.randint(0, 7)
        data_list[byte_idx] ^= (1 << bit_idx)
        return bytes(data_list)

    def mutate_byte_flip(self, data: bytes) -> bytes:
        """Flip random bytes."""
        if not data:
            return data

        data_list = bytearray(data)
        idx = random.randint(0, len(data_list) - 1)
        data_list[idx] = random.randint(0, 255)
        return bytes(data_list)

    def mutate_byte_insert(self, data: bytes) -> bytes:
        """Insert random bytes."""
        data_list = bytearray(data)
        insert_pos = random.randint(0, len(data_list))
        insert_byte = random.randint(0, 255)
        data_list.insert(insert_pos, insert_byte)
        return bytes(data_list)

    def mutate_byte_delete(self, data: bytes) -> bytes:
        """Delete a random byte."""
        if len(data) <= 1:
            return data

        data_list = bytearray(data)
        idx = random.randint(0, len(data_list) - 1)
        del data_list[idx]
        return bytes(data_list)

    def mutate_interesting_values(self, data: bytes) -> bytes:
        """Replace with interesting boundary values."""
        if not data:
            return bytes([0xFF, 0x00, 0x7F, 0x80])

        data_list = bytearray(data)
        interesting = [0x00, 0x01, 0x7F, 0x80, 0xFF]
        idx = random.randint(0, len(data_list) - 1)
        data_list[idx] = random.choice(interesting)
        return bytes(data_list)

    def mutate_chunk(self, data: bytes) -> bytes:
        """Repeat or manipulate chunks of data."""
        if len(data) < 2:
            return data * 2

        chunk_size = random.randint(1, len(data) // 2)
        chunk_start = random.randint(0, len(data) - chunk_size)
        chunk = data[chunk_start:chunk_start + chunk_size]

        return data + (chunk * random.randint(2, 5))

    def save_crash(self, crash_data: bytes, crash_dir: str, name: str):
        """Save crash input to file.

        Args:
            crash_data: The input that caused the crash
            crash_dir: Directory to save crashes
            name: Name for the crash file
        """
        crash_path = Path(crash_dir) / f"{name}.crash"
        crash_path.write_bytes(crash_data)

    def build_afl_command(
        self,
        binary_path: str,
        corpus_dir: str,
        output_dir: str,
        timeout: int
    ) -> List[str]:
        """Build AFL++ command line.

        Args:
            binary_path: Path to binary
            corpus_dir: Corpus directory
            output_dir: Output directory
            timeout: Timeout in seconds

        Returns:
            Command as list of arguments
        """
        return [
            'afl-fuzz',
            '-i', corpus_dir,
            '-o', output_dir,
            '-t', '1000',  # 1 second timeout per execution
            '-m', 'none',  # No memory limit
            '--', binary_path
        ]

    def _parse_afl_iterations(self, output_dir: Path) -> int:
        """Parse AFL++ output to get iteration count.

        Args:
            output_dir: AFL++ output directory

        Returns:
            Number of iterations (approximation)
        """
        fuzzer_stats = output_dir / "fuzzer_stats"
        if fuzzer_stats.exists():
            try:
                content = fuzzer_stats.read_text()
                for line in content.split('\n'):
                    if 'execs_done' in line:
                        return int(line.split(':')[1].strip())
            except Exception:
                pass

        return 0

    def _hash_file(self, file_path: Path) -> str:
        """Calculate hash of file.

        Args:
            file_path: Path to file

        Returns:
            MD5 hash of file contents
        """
        return hashlib.md5(file_path.read_bytes()).hexdigest()
