# Akali Fuzzing Framework

Comprehensive fuzzing framework for vulnerability discovery through binary and network protocol fuzzing.

## Features

### Binary Fuzzing
- **AFL++ Integration**: Automatic detection and use of AFL++ if available
- **Python Fallback**: Pure Python mutation-based fuzzer
- **Crash Detection**: Signal-based crash detection (SIGSEGV, SIGABRT, etc.)
- **Multiple Mutation Strategies**: Bit flips, byte manipulations, interesting values

### Network Fuzzing
- **Protocol Support**: TCP, UDP, HTTP
- **Concurrent Fuzzing**: Multi-threaded fuzzing for performance
- **Anomaly Detection**: Detects timeouts, large responses, connection errors
- **Corpus-Based**: Supports seed inputs from corpus directory

### Crash Analysis
- **Exploitability Scoring**: Rates crashes as High/Medium/Low/Unknown
- **Crash Type Detection**: Buffer overflow, format string, null deref, etc.
- **Deduplication**: Hash-based crash uniqueness detection
- **Prioritization**: Automatic ranking by exploitability score

## Quick Start

### 1. Binary Fuzzing

```bash
# Basic fuzzing with sample corpus
./akali fuzz binary ./test_vulnerable --corpus ./exploits/fuzzer/corpus --timeout 60

# Long-running fuzzing session
./akali fuzz binary /path/to/app --corpus ./seeds --timeout 3600
```

**Output**:
- Crash files saved to `crashes/` directory
- Results include iteration count, crash count, unique crashes

### 2. Network Fuzzing

```bash
# Fuzz TCP service
./akali fuzz network 192.168.1.100 --port 8080 --protocol tcp --iterations 1000

# Fuzz HTTP service
./akali fuzz network example.com --port 80 --protocol http --iterations 500

# Use custom corpus
./akali fuzz network 10.0.0.5 --port 9000 --corpus ./http_seeds
```

### 3. Crash Analysis

```bash
# Analyze crashes
./akali fuzz analyze ./crashes

# Generate detailed JSON report
./akali fuzz analyze ./crashes --report
```

## Corpus Files

Pre-configured seed files in `corpus/`:

1. **http_get.txt** - HTTP GET request template
2. **http_post.txt** - HTTP POST with JSON payload
3. **simple_text.txt** - Basic text input
4. **binary_data.bin** - Binary data
5. **json_payload.txt** - JSON structure

### Creating Custom Corpus

```bash
mkdir my_corpus
echo "GET / HTTP/1.1" > my_corpus/seed1.txt
echo -n -e "\x00\x01\x02\x03" > my_corpus/seed2.bin
```

## Test Vulnerable Program

A sample vulnerable program is included for testing:

```bash
# Compile (already done)
gcc -o test_vulnerable test_vulnerable.c

# Normal execution
./test_vulnerable "hello"

# Trigger crash (demonstrates vulnerability)
./test_vulnerable $(python3 -c "print('A' * 100)")

# Fuzz it
./akali fuzz binary ./exploits/fuzzer/test_vulnerable --corpus ./exploits/fuzzer/corpus --timeout 30
```

## Architecture

### Module Structure

```
exploits/fuzzer/
├── __init__.py              # Package exports
├── fuzzing.py               # Main Fuzzer orchestrator
├── binary_fuzzer.py         # Binary fuzzing engine
├── network_fuzzer.py        # Network protocol fuzzer
├── crash_analyzer.py        # Crash analysis and scoring
├── corpus/                  # Sample seed files
│   ├── http_get.txt
│   ├── http_post.txt
│   ├── simple_text.txt
│   ├── json_payload.txt
│   └── binary_data.bin
├── test_vulnerable.c        # Test program source
├── test_vulnerable          # Compiled test binary
└── README.md               # This file
```

### Class Hierarchy

```
Fuzzer (fuzzing.py)
├── BinaryFuzzer (binary_fuzzer.py)
│   ├── fuzz_with_afl()
│   └── fuzz_with_python()
├── NetworkFuzzer (network_fuzzer.py)
│   ├── fuzz_tcp()
│   ├── fuzz_udp()
│   └── fuzz_http()
└── CrashAnalyzer (crash_analyzer.py)
    ├── analyze_directory()
    └── calculate_exploitability()
```

## Mutation Strategies

### Binary Mutations
1. **Bit Flip**: Flip random bits (1-3 per mutation)
2. **Byte Flip**: Replace random bytes
3. **Byte Insert**: Insert random data
4. **Byte Delete**: Remove random bytes
5. **Chunk Repeat**: Repeat chunks of data
6. **Interesting Values**: Inject boundary values (0x00, 0xFF, 0x7FFF, etc.)

### Network Mutations
- Protocol-aware HTTP mutation (preserves structure)
- Random payload generation
- Corpus-based seed mutation
- Pattern-based fuzzing

## Crash Detection

### Signal Detection
- SIGSEGV (Segmentation fault)
- SIGABRT (Abort)
- SIGILL (Illegal instruction)
- SIGFPE (Floating point exception)
- SIGBUS (Bus error)

### Return Code Analysis
- Exit code 139 (SIGSEGV)
- Exit code 134 (SIGABRT)
- Negative signals (-11, -6, etc.)

### Stderr Parsing
Keywords: "segmentation fault", "core dumped", "abort"

## Exploitability Scoring

### Scoring Algorithm

```python
Score = 0-10 based on:
- Crash type weight (buffer_overflow: +5, format_string: +5)
- Control flow signals (RIP control: +3)
- Pattern analysis (repeating bytes: +1)
- Input size (optimal range: +1-2)

Rating:
- High: >= 7 (Likely exploitable)
- Medium: >= 4 (Possibly exploitable)
- Low: >= 2 (Unlikely exploitable)
- Unknown: < 2 (Insufficient data)
```

### Crash Types Detected
- Buffer overflow
- Format string
- Null dereference
- Heap corruption
- Stack overflow
- Use-after-free patterns

## Performance

### Binary Fuzzing
- **AFL++ Mode**: ~10,000+ execs/sec (hardware dependent)
- **Python Mode**: ~50-100 execs/sec
- **Crash Saving**: Automatic with deduplication

### Network Fuzzing
- **Sequential**: ~100-500 requests/sec
- **Concurrent (5 workers)**: ~500-2000 requests/sec
- **Error Recovery**: Continues despite failures

### Crash Analysis
- **Processing**: ~1000+ crashes/sec
- **Memory**: Streaming analysis for large sets

## API Usage

### Programmatic Access

```python
from exploits.fuzzer import Fuzzer

# Create fuzzer instance
fuzzer = Fuzzer()

# Fuzz binary
result = fuzzer.fuzz_binary(
    binary_path="/path/to/app",
    corpus_dir="./seeds",
    timeout=3600
)

print(f"Iterations: {result['iterations']}")
print(f"Crashes: {result['crashes']}")

# Fuzz network
result = fuzzer.fuzz_network(
    target="192.168.1.100",
    port=8080,
    protocol="tcp",
    iterations=1000
)

# Analyze crashes
crashes = fuzzer.analyze_crashes("./crashes")
for crash in crashes:
    print(f"{crash['file']}: {crash['exploitability']}")
```

### Custom Mutations

```python
from exploits.fuzzer import Fuzzer

fuzzer = Fuzzer()

# Generate 100 mutations of seed
seed = b"GET / HTTP/1.1\r\n\r\n"
mutations = fuzzer.mutate_input(seed, mutations=100)

for mutated in mutations[:5]:
    print(mutated)
```

## Testing

Run the test suite:

```bash
# All fuzzer tests
python3 -m pytest tests/exploits/fuzzer/ -v

# Specific test file
python3 -m pytest tests/exploits/fuzzer/test_fuzzing.py -v

# With coverage
python3 -m pytest tests/exploits/fuzzer/ --cov=exploits.fuzzer
```

**Test Coverage**: 64 tests, 63 passing

## Security Considerations

### Authorization
Network fuzzing requires explicit user consent via interactive prompt.

### Safe Defaults
- Reasonable iteration limits
- Timeout enforcement
- Error handling to prevent tool crashes

### Warning Messages
Clear warnings about potential service disruption during network fuzzing.

## Dependencies

### Required
- Python 3.8+
- Standard library only (socket, subprocess, threading, etc.)

### Optional
- **AFL++**: For high-performance binary fuzzing
  ```bash
  # Ubuntu/Debian
  apt install afl++

  # macOS
  brew install afl++
  ```
- **GCC**: For compiling test vulnerable program
  ```bash
  # Ubuntu/Debian
  apt install gcc

  # macOS
  xcode-select --install
  ```

## Troubleshooting

### No crashes found
- Increase timeout: `--timeout 7200`
- Add more diverse seeds to corpus
- Check if target is actually vulnerable
- Try different mutation strategies

### High error rate in network fuzzing
- Verify target is reachable
- Check firewall rules
- Reduce concurrent workers
- Increase timeout per request

### AFL++ not detected
- Install AFL++ or use Python fallback
- Check `afl-fuzz` is in PATH
- Python fallback is automatic

## Future Enhancements

- Grammar-based fuzzing for complex protocols
- Coverage-guided fuzzing
- Machine learning for crash prediction
- Distributed fuzzing support
- More protocol support (FTP, SMTP, DNS)

## License

Part of Akali Security Platform

## Contributing

This is part of the Akali project. See main README for contribution guidelines.

## Support

For issues or questions, refer to main Akali documentation.
