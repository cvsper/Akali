"""Main fuzzer class that orchestrates fuzzing operations."""

import random
from pathlib import Path
from typing import Dict, List, Optional
from .binary_fuzzer import BinaryFuzzer
from .network_fuzzer import NetworkFuzzer
from .crash_analyzer import CrashAnalyzer


class Fuzzer:
    """Main fuzzer class for binary and network fuzzing."""

    def __init__(self):
        """Initialize the fuzzer."""
        self.binary_fuzzer = BinaryFuzzer()
        self.network_fuzzer = NetworkFuzzer()
        self.crash_analyzer = CrashAnalyzer()

    def fuzz_binary(
        self,
        binary_path: str,
        corpus_dir: str,
        timeout: int = 3600
    ) -> Dict:
        """Fuzz a binary application.

        Args:
            binary_path: Path to binary to fuzz
            corpus_dir: Directory containing seed inputs
            timeout: Fuzzing timeout in seconds

        Returns:
            Dictionary with fuzzing results

        Raises:
            FileNotFoundError: If binary or corpus doesn't exist
            ValueError: If inputs are invalid
        """
        # Validate inputs
        binary = Path(binary_path)
        if not binary.exists():
            raise FileNotFoundError(f"Binary not found: {binary_path}")

        corpus = Path(corpus_dir)
        if not corpus.exists():
            raise FileNotFoundError(f"Corpus directory not found: {corpus_dir}")

        # Check if AFL++ is available, otherwise use Python fuzzer
        if self.binary_fuzzer.check_afl_available():
            result = self.binary_fuzzer.fuzz_with_afl(
                binary_path,
                corpus_dir,
                timeout
            )
        else:
            result = self.binary_fuzzer.fuzz_with_python(
                binary_path,
                corpus_dir,
                timeout
            )

        return result

    def fuzz_network(
        self,
        target: str,
        port: int,
        protocol: str = 'tcp',
        iterations: int = 1000,
        corpus_dir: Optional[str] = None,
        timeout_per_request: float = 1.0
    ) -> Dict:
        """Fuzz a network service.

        Args:
            target: Target hostname or IP
            port: Target port
            protocol: Protocol to fuzz (tcp, udp, http)
            iterations: Number of fuzzing iterations
            corpus_dir: Optional directory with seed inputs
            timeout_per_request: Timeout per request in seconds

        Returns:
            Dictionary with fuzzing results
        """
        # Load seeds from corpus if provided
        seeds = None
        if corpus_dir:
            corpus = Path(corpus_dir)
            if corpus.exists():
                seeds = []
                for seed_file in corpus.glob('*'):
                    if seed_file.is_file():
                        seeds.append(seed_file.read_bytes())

        # Dispatch to appropriate protocol handler
        if protocol.lower() == 'tcp':
            result = self.network_fuzzer.fuzz_tcp(
                target=target,
                port=port,
                iterations=iterations,
                seeds=seeds,
                timeout_per_request=timeout_per_request
            )
        elif protocol.lower() == 'udp':
            result = self.network_fuzzer.fuzz_udp(
                target=target,
                port=port,
                iterations=iterations,
                seeds=seeds,
                timeout_per_request=timeout_per_request
            )
        elif protocol.lower() == 'http':
            target_url = target if target.startswith('http') else f'http://{target}:{port}'
            result = self.network_fuzzer.fuzz_http(
                target=target_url,
                iterations=iterations,
                timeout_per_request=timeout_per_request
            )
        else:
            raise ValueError(f"Unsupported protocol: {protocol}")

        result['protocol'] = protocol
        result['corpus_used'] = corpus_dir is not None

        return result

    def analyze_crashes(self, crash_dir: str) -> List[Dict]:
        """Analyze crash files for exploitability.

        Args:
            crash_dir: Directory containing crash files

        Returns:
            List of analyzed crashes with exploitability scores
        """
        results = self.crash_analyzer.analyze_directory(crash_dir)
        return results

    def mutate_input(self, seed: bytes, mutations: int = 100) -> List[bytes]:
        """Generate mutations of a seed input.

        Args:
            seed: Original seed input
            mutations: Number of mutations to generate

        Returns:
            List of mutated inputs
        """
        mutated_inputs = []

        for _ in range(mutations):
            # Randomly choose a mutation strategy
            strategy = random.choice([
                self._mutate_bit_flip,
                self._mutate_byte_flip,
                self._mutate_byte_insert,
                self._mutate_byte_delete,
                self._mutate_chunk_repeat,
                self._mutate_interesting_values
            ])

            mutated = strategy(seed)
            mutated_inputs.append(mutated)

        return mutated_inputs

    def _mutate_bit_flip(self, data: bytes) -> bytes:
        """Flip random bits in the data."""
        if not data:
            return data

        data_list = bytearray(data)
        # Flip 1-3 random bits
        num_flips = random.randint(1, 3)
        for _ in range(num_flips):
            byte_idx = random.randint(0, len(data_list) - 1)
            bit_idx = random.randint(0, 7)
            data_list[byte_idx] ^= (1 << bit_idx)

        return bytes(data_list)

    def _mutate_byte_flip(self, data: bytes) -> bytes:
        """Flip random bytes in the data."""
        if not data:
            return data

        data_list = bytearray(data)
        num_flips = random.randint(1, min(5, len(data_list)))
        for _ in range(num_flips):
            idx = random.randint(0, len(data_list) - 1)
            data_list[idx] = random.randint(0, 255)

        return bytes(data_list)

    def _mutate_byte_insert(self, data: bytes) -> bytes:
        """Insert random bytes into the data."""
        data_list = bytearray(data)
        insert_pos = random.randint(0, len(data_list))
        num_bytes = random.randint(1, 10)
        insert_data = bytes([random.randint(0, 255) for _ in range(num_bytes)])

        return bytes(data_list[:insert_pos] + insert_data + data_list[insert_pos:])

    def _mutate_byte_delete(self, data: bytes) -> bytes:
        """Delete random bytes from the data."""
        if len(data) <= 1:
            return data

        data_list = bytearray(data)
        num_delete = random.randint(1, min(5, len(data_list) - 1))
        for _ in range(num_delete):
            if len(data_list) > 1:
                idx = random.randint(0, len(data_list) - 1)
                del data_list[idx]

        return bytes(data_list)

    def _mutate_chunk_repeat(self, data: bytes) -> bytes:
        """Repeat a chunk of data."""
        if len(data) < 2:
            return data * random.randint(2, 5)

        chunk_size = random.randint(1, min(20, len(data)))
        chunk_start = random.randint(0, len(data) - chunk_size)
        chunk = data[chunk_start:chunk_start + chunk_size]

        repeat_count = random.randint(2, 10)
        insert_pos = random.randint(0, len(data))

        return data[:insert_pos] + (chunk * repeat_count) + data[insert_pos:]

    def _mutate_interesting_values(self, data: bytes) -> bytes:
        """Replace bytes with interesting values (boundaries, etc)."""
        if not data:
            # If empty, create data with interesting values
            interesting = [0x00, 0xFF, 0x7F, 0x80]
            return bytes([random.choice(interesting) for _ in range(4)])

        data_list = bytearray(data)

        # Interesting values
        interesting_8bit = [0x00, 0x01, 0x7F, 0x80, 0xFF]
        interesting_16bit = [0x0000, 0x0001, 0x7FFF, 0x8000, 0xFFFF]
        interesting_32bit = [0x00000000, 0x00000001, 0x7FFFFFFF, 0x80000000, 0xFFFFFFFF]

        # Replace some bytes with interesting values
        num_replacements = random.randint(1, min(3, len(data_list)))
        for _ in range(num_replacements):
            idx = random.randint(0, len(data_list) - 1)

            # Choose value type
            value_type = random.choice(['8bit', '16bit', '32bit'])

            if value_type == '8bit':
                data_list[idx] = random.choice(interesting_8bit)
            elif value_type == '16bit' and idx < len(data_list) - 1:
                value = random.choice(interesting_16bit)
                data_list[idx] = value & 0xFF
                data_list[idx + 1] = (value >> 8) & 0xFF
            elif value_type == '32bit' and idx < len(data_list) - 3:
                value = random.choice(interesting_32bit)
                data_list[idx] = value & 0xFF
                data_list[idx + 1] = (value >> 8) & 0xFF
                data_list[idx + 2] = (value >> 16) & 0xFF
                data_list[idx + 3] = (value >> 24) & 0xFF

        return bytes(data_list)
