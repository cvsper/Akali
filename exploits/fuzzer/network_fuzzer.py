"""Network protocol fuzzing."""

import socket
import random
import time
import hashlib
from pathlib import Path
from typing import Dict, List, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed


class NetworkFuzzer:
    """Network protocol fuzzer for TCP, UDP, and HTTP."""

    def __init__(self):
        """Initialize network fuzzer."""
        self.response_cache = set()

    def fuzz_tcp(
        self,
        target: str,
        port: int,
        iterations: int = 1000,
        seeds: Optional[List[bytes]] = None,
        corpus_dir: Optional[str] = None,
        timeout_per_request: float = 1.0,
        concurrent: bool = False,
        max_workers: int = 5
    ) -> Dict:
        """Fuzz TCP service.

        Args:
            target: Target hostname or IP
            port: Target port
            iterations: Number of fuzzing iterations
            seeds: Optional list of seed inputs
            corpus_dir: Optional corpus directory
            timeout_per_request: Timeout per request in seconds
            concurrent: Use concurrent fuzzing
            max_workers: Max concurrent workers

        Returns:
            Dictionary with fuzzing results
        """
        # Load seeds from corpus if provided
        if corpus_dir:
            corpus_path = Path(corpus_dir)
            if corpus_path.exists():
                seeds = []
                for seed_file in corpus_path.glob('*'):
                    if seed_file.is_file():
                        seeds.append(seed_file.read_bytes())

        # Default seeds if none provided
        if not seeds:
            seeds = self.generate_tcp_payloads(count=10)

        results = {
            'iterations': iterations,
            'responses': [],
            'anomalies': [],
            'errors': 0,
            'unique_responses': 0,
            'corpus_seeds': len(seeds) if corpus_dir else 0,
            'seed_based': seeds is not None
        }

        if concurrent:
            results = self._fuzz_tcp_concurrent(
                target, port, iterations, seeds, timeout_per_request, max_workers, results
            )
        else:
            results = self._fuzz_tcp_sequential(
                target, port, iterations, seeds, timeout_per_request, results
            )

        results['unique_responses'] = len(self.response_cache)
        return results

    def _fuzz_tcp_sequential(
        self,
        target: str,
        port: int,
        iterations: int,
        seeds: List[bytes],
        timeout: float,
        results: Dict
    ) -> Dict:
        """Sequential TCP fuzzing."""
        for i in range(iterations):
            # Generate or mutate payload
            if seeds and random.random() < 0.7:
                payload = self.mutate_payload(random.choice(seeds))
            else:
                payload = self.generate_tcp_payloads(count=1)[0]

            # Send payload and measure response
            start_time = time.time()
            try:
                response = self._send_tcp(target, port, payload, timeout)
                response_time = time.time() - start_time

                # Track unique responses
                response_hash = hashlib.md5(response).hexdigest()
                self.response_cache.add(response_hash)

                results['responses'].append({
                    'iteration': i,
                    'response_hash': response_hash,
                    'response_size': len(response),
                    'response_time': response_time
                })

                # Check for anomalies
                anomaly = self.detect_anomaly(response_time, 'success', response)
                if anomaly:
                    results['anomalies'].append(anomaly)

            except socket.timeout:
                anomaly = self.detect_anomaly(timeout, 'timeout', b'')
                if anomaly:
                    results['anomalies'].append(anomaly)
                results['errors'] += 1

            except Exception as e:
                anomaly = self.detect_anomaly(0, 'connection_refused', b'')
                if anomaly:
                    results['anomalies'].append(anomaly)
                results['errors'] += 1

        return results

    def _fuzz_tcp_concurrent(
        self,
        target: str,
        port: int,
        iterations: int,
        seeds: List[bytes],
        timeout: float,
        max_workers: int,
        results: Dict
    ) -> Dict:
        """Concurrent TCP fuzzing."""
        def fuzz_iteration(i):
            if seeds and random.random() < 0.7:
                payload = self.mutate_payload(random.choice(seeds))
            else:
                payload = self.generate_tcp_payloads(count=1)[0]

            start_time = time.time()
            try:
                response = self._send_tcp(target, port, payload, timeout)
                response_time = time.time() - start_time

                response_hash = hashlib.md5(response).hexdigest()
                self.response_cache.add(response_hash)

                return {
                    'type': 'success',
                    'iteration': i,
                    'response_hash': response_hash,
                    'response_size': len(response),
                    'response_time': response_time,
                    'response': response
                }
            except socket.timeout:
                return {'type': 'timeout'}
            except Exception:
                return {'type': 'error'}

        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = [executor.submit(fuzz_iteration, i) for i in range(iterations)]

            for future in as_completed(futures):
                result = future.result()

                if result['type'] == 'success':
                    results['responses'].append({
                        'iteration': result['iteration'],
                        'response_hash': result['response_hash'],
                        'response_size': result['response_size'],
                        'response_time': result['response_time']
                    })

                    anomaly = self.detect_anomaly(
                        result['response_time'],
                        'success',
                        result['response']
                    )
                    if anomaly:
                        results['anomalies'].append(anomaly)
                else:
                    results['errors'] += 1

        return results

    def _send_tcp(self, target: str, port: int, data: bytes, timeout: float) -> bytes:
        """Send data via TCP and return response.

        Args:
            target: Target host
            port: Target port
            data: Data to send
            timeout: Socket timeout

        Returns:
            Response data

        Raises:
            socket.timeout: On timeout
            Exception: On connection errors
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)

        try:
            sock.connect((target, port))
            sock.sendall(data)
            response = sock.recv(4096)
            return response
        finally:
            sock.close()

    def fuzz_udp(
        self,
        target: str,
        port: int,
        iterations: int = 1000,
        seeds: Optional[List[bytes]] = None,
        timeout_per_request: float = 1.0
    ) -> Dict:
        """Fuzz UDP service.

        Args:
            target: Target hostname or IP
            port: Target port
            iterations: Number of fuzzing iterations
            seeds: Optional list of seed inputs
            timeout_per_request: Timeout per request

        Returns:
            Dictionary with fuzzing results
        """
        if not seeds:
            seeds = self.generate_tcp_payloads(count=10)

        results = {
            'iterations': iterations,
            'responses': [],
            'errors': 0
        }

        for i in range(iterations):
            payload = self.mutate_payload(random.choice(seeds))

            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(timeout_per_request)

                sock.sendto(payload, (target, port))

                try:
                    response, addr = sock.recvfrom(4096)
                    results['responses'].append({
                        'iteration': i,
                        'response_size': len(response)
                    })
                except socket.timeout:
                    pass

                sock.close()

            except Exception:
                results['errors'] += 1

        return results

    def fuzz_http(
        self,
        target: str,
        iterations: int = 1000,
        timeout_per_request: float = 1.0
    ) -> Dict:
        """Fuzz HTTP service.

        Args:
            target: Target URL
            iterations: Number of fuzzing iterations
            timeout_per_request: Timeout per request

        Returns:
            Dictionary with fuzzing results
        """
        # Parse URL
        if '://' not in target:
            target = 'http://' + target

        results = {
            'iterations': iterations,
            'requests': [],
            'anomalies': [],
            'errors': 0
        }

        for i in range(iterations):
            request_data = random.choice(self.generate_http_requests(count=1))

            # Extract host and port from target
            try:
                from urllib.parse import urlparse
                parsed = urlparse(target)
                host = parsed.hostname or '127.0.0.1'
                port = parsed.port or 80

                start_time = time.time()
                response = self._send_tcp(host, port, request_data, timeout_per_request)
                response_time = time.time() - start_time

                results['requests'].append({
                    'iteration': i,
                    'response_size': len(response),
                    'response_time': response_time
                })

                anomaly = self.detect_anomaly(response_time, 'success', response)
                if anomaly:
                    results['anomalies'].append(anomaly)

            except Exception:
                results['errors'] += 1

        return results

    def generate_tcp_payloads(self, count: int = 10) -> List[bytes]:
        """Generate random TCP payloads.

        Args:
            count: Number of payloads to generate

        Returns:
            List of payload bytes
        """
        payloads = []

        for _ in range(count):
            payload_type = random.choice(['random', 'repeated', 'boundary'])

            if payload_type == 'random':
                size = random.randint(1, 1024)
                payload = bytes([random.randint(0, 255) for _ in range(size)])
            elif payload_type == 'repeated':
                char = random.choice([b'A', b'B', b'\x00', b'\xFF'])
                size = random.randint(10, 2048)
                payload = char * size
            else:  # boundary
                payload = bytes([0x00, 0x01, 0x7F, 0x80, 0xFF] * random.randint(1, 100))

            payloads.append(payload)

        return payloads

    def generate_http_requests(self, count: int = 10) -> List[bytes]:
        """Generate HTTP request payloads.

        Args:
            count: Number of requests to generate

        Returns:
            List of HTTP request bytes
        """
        methods = [b'GET', b'POST', b'PUT', b'DELETE', b'HEAD', b'OPTIONS', b'TRACE']
        paths = [b'/', b'/admin', b'/api', b'/../../../etc/passwd', b'/api/v1/users']
        versions = [b'HTTP/1.0', b'HTTP/1.1', b'HTTP/2.0']

        requests = []

        for _ in range(count):
            method = random.choice(methods)
            path = random.choice(paths)
            version = random.choice(versions)

            request = method + b' ' + path + b' ' + version + b'\r\n'
            request += b'Host: target.com\r\n'

            # Add random headers
            if random.random() < 0.5:
                request += b'Content-Length: ' + str(random.randint(0, 10000)).encode() + b'\r\n'

            request += b'\r\n'

            # Add body for POST/PUT
            if method in [b'POST', b'PUT'] and random.random() < 0.5:
                body_size = random.randint(0, 500)
                request += bytes([random.randint(0, 127) for _ in range(body_size)])

            requests.append(request)

        return requests

    def mutate_payload(self, seed: bytes) -> bytes:
        """Mutate a payload.

        Args:
            seed: Original payload

        Returns:
            Mutated payload
        """
        strategies = [
            lambda d: self._flip_bits(d),
            lambda d: self._insert_bytes(d),
            lambda d: self._delete_bytes(d),
            lambda d: self._repeat_chunk(d)
        ]

        return random.choice(strategies)(seed)

    def mutate_http_payload(self, seed: bytes) -> bytes:
        """Mutate HTTP payload while preserving some structure.

        Args:
            seed: Original HTTP request

        Returns:
            Mutated HTTP request
        """
        # Try to preserve HTTP structure
        if b'HTTP' in seed:
            parts = seed.split(b'\r\n\r\n', 1)
            headers = parts[0]
            body = parts[1] if len(parts) > 1 else b''

            # Mutate body
            if body:
                body = self.mutate_payload(body)

            # Occasionally mutate headers too
            if random.random() < 0.3:
                headers = self.mutate_payload(headers)

            return headers + b'\r\n\r\n' + body
        else:
            return self.mutate_payload(seed)

    def _flip_bits(self, data: bytes) -> bytes:
        """Flip random bits in data."""
        if not data:
            return data

        data_list = bytearray(data)
        num_flips = random.randint(1, min(5, len(data_list)))

        for _ in range(num_flips):
            byte_idx = random.randint(0, len(data_list) - 1)
            bit_idx = random.randint(0, 7)
            data_list[byte_idx] ^= (1 << bit_idx)

        return bytes(data_list)

    def _insert_bytes(self, data: bytes) -> bytes:
        """Insert random bytes into data."""
        data_list = bytearray(data)
        insert_pos = random.randint(0, len(data_list))
        num_bytes = random.randint(1, 20)
        insert_data = bytes([random.randint(0, 255) for _ in range(num_bytes)])

        return bytes(data_list[:insert_pos] + insert_data + data_list[insert_pos:])

    def _delete_bytes(self, data: bytes) -> bytes:
        """Delete random bytes from data."""
        if len(data) <= 1:
            return data

        data_list = bytearray(data)
        num_delete = random.randint(1, min(10, len(data_list) - 1))

        for _ in range(num_delete):
            if len(data_list) > 1:
                idx = random.randint(0, len(data_list) - 1)
                del data_list[idx]

        return bytes(data_list)

    def _repeat_chunk(self, data: bytes) -> bytes:
        """Repeat a chunk of data."""
        if len(data) < 2:
            return data * random.randint(2, 5)

        chunk_size = random.randint(1, min(50, len(data)))
        chunk_start = random.randint(0, len(data) - chunk_size)
        chunk = data[chunk_start:chunk_start + chunk_size]

        return data + (chunk * random.randint(2, 10))

    def detect_anomaly(
        self,
        response_time: float,
        status: str,
        response_data: bytes
    ) -> Optional[Dict]:
        """Detect anomalies in responses.

        Args:
            response_time: Response time in seconds
            status: Response status (success, timeout, error)
            response_data: Response data

        Returns:
            Anomaly dict if detected, None otherwise
        """
        # Timeout anomaly
        if status == 'timeout':
            return {
                'type': 'timeout',
                'response_time': response_time
            }

        # Connection error anomaly
        if status == 'connection_refused':
            return {
                'type': 'connection_error'
            }

        # Large response anomaly
        if len(response_data) > 50000:
            return {
                'type': 'large_response',
                'size': len(response_data)
            }

        # Slow response anomaly
        if response_time > 3.0:
            return {
                'type': 'slow_response',
                'response_time': response_time
            }

        return None
