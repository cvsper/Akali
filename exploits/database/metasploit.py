"""Metasploit framework module search."""

import subprocess
import re
from typing import List, Dict, Optional


class MetasploitSearch:
    """Search Metasploit framework modules."""

    def __init__(self):
        """Initialize Metasploit search."""
        self.msfconsole_bin = "msfconsole"

    def check_available(self) -> bool:
        """Check if Metasploit is available.

        Returns:
            True if msfconsole is installed, False otherwise
        """
        try:
            result = subprocess.run(
                [self.msfconsole_bin, "-h"],
                capture_output=True,
                timeout=10
            )
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def search(self, query: str) -> List[Dict]:
        """Search Metasploit modules.

        Args:
            query: Search query string

        Returns:
            List of module dictionaries
        """
        if not self.check_available():
            return []

        try:
            # Use msfconsole search command
            cmd = f"search {query}"
            result = subprocess.run(
                [self.msfconsole_bin, "-q", "-x", f"{cmd}; exit"],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0 and result.stdout:
                return self._parse_module_list(result.stdout)

        except (subprocess.TimeoutExpired, Exception):
            pass

        return []

    def get_module_info(self, module_name: str) -> Optional[Dict]:
        """Get detailed information about a module.

        Args:
            module_name: Full module name (e.g., exploit/windows/smb/ms17_010_eternalblue)

        Returns:
            Module information dictionary or None
        """
        if not self.check_available():
            return None

        try:
            cmd = f"info {module_name}"
            result = subprocess.run(
                [self.msfconsole_bin, "-q", "-x", f"{cmd}; exit"],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0 and result.stdout:
                return self._parse_module_info(result.stdout)

        except (subprocess.TimeoutExpired, Exception):
            pass

        return None

    def get_module_options(self, module_name: str) -> List[Dict]:
        """Get module options/parameters.

        Args:
            module_name: Full module name

        Returns:
            List of option dictionaries
        """
        if not self.check_available():
            return []

        try:
            cmd = f"use {module_name}; show options"
            result = subprocess.run(
                [self.msfconsole_bin, "-q", "-x", f"{cmd}; exit"],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0 and result.stdout:
                return self._parse_options(result.stdout)

        except (subprocess.TimeoutExpired, Exception):
            pass

        return []

    def _parse_module_list(self, output: str) -> List[Dict]:
        """Parse module search output.

        Args:
            output: Raw msfconsole output

        Returns:
            List of module dictionaries
        """
        results = []

        # Parse module table output
        # Format:  #  Name  Disclosure Date  Rank  Check  Description
        lines = output.split('\n')

        for line in lines:
            # Skip header/separator lines
            if not line.strip() or line.startswith('#') or line.startswith('-') or 'Name' in line:
                continue

            # Extract module info using regex
            # Match format: number, name, optional date, rank, check, description
            match = re.match(
                r'\s*\d+\s+([\w/]+)\s+(?:(\d{4}-\d{2}-\d{2})\s+)?(\w+)\s+(Yes|No)\s+(.+)',
                line
            )

            if match:
                module_name = match.group(1)
                disclosure_date = match.group(2)
                rank = match.group(3)
                check = match.group(4)
                description = match.group(5).strip()

                # Determine module type from name
                module_type = 'exploit' if module_name.startswith('exploit/') else \
                             'auxiliary' if module_name.startswith('auxiliary/') else \
                             'post' if module_name.startswith('post/') else 'other'

                results.append({
                    'name': module_name,
                    'type': module_type,
                    'disclosure_date': disclosure_date,
                    'rank': rank.lower() if rank else None,
                    'check': check == 'Yes',
                    'description': description,
                    'source': 'metasploit'
                })

        return results

    def _parse_module_info(self, output: str) -> Dict:
        """Parse module info output.

        Args:
            output: Raw info command output

        Returns:
            Module information dictionary
        """
        info = {}

        lines = output.split('\n')
        for line in lines:
            # Parse key: value pairs
            if ':' in line and not line.strip().startswith('#'):
                parts = line.split(':', 1)
                if len(parts) == 2:
                    key = parts[0].strip().lower().replace(' ', '_')
                    value = parts[1].strip()
                    info[key] = value

        return info

    def _parse_options(self, output: str) -> List[Dict]:
        """Parse module options output.

        Args:
            output: Raw show options output

        Returns:
            List of option dictionaries
        """
        options = []

        lines = output.split('\n')
        parsing_options = False
        header_found = False

        for line in lines:
            # Start parsing after "Module options" header
            if 'Module options' in line:
                parsing_options = True
                continue

            # Skip empty lines at start
            if parsing_options and not line.strip():
                if header_found:
                    break  # End of options table
                continue

            # Skip header line
            if parsing_options and ('Name' in line and 'Description' in line):
                header_found = True
                continue

            # Skip separator line
            if parsing_options and '----' in line:
                continue

            # Stop at next section
            if parsing_options and 'Payload options' in line:
                break

            # Parse option lines
            if parsing_options and header_found and line.strip():
                # Split by multiple spaces (2 or more)
                parts = re.split(r'\s{2,}', line.strip())
                if len(parts) >= 3:
                    options.append({
                        'name': parts[0],
                        'current_value': parts[1],
                        'required': parts[2].lower() == 'yes',
                        'description': parts[3] if len(parts) > 3 else ''
                    })

        return options
