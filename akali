#!/usr/bin/env python3
"""Akali - The Security Sentinel CLI."""

import sys
import argparse
from pathlib import Path

# Add core to path
sys.path.append(str(Path.home() / "akali" / "core"))

from cli import AkaliCLI
from ascii_art import AKALI_BANNER


def main():
    parser = argparse.ArgumentParser(
        description=AKALI_BANNER + "\n",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Defensive Examples:
  akali scan .                    # Scan current directory
  akali scan ~/project            # Scan specific directory
  akali scan --secrets-only       # Run only secrets scanner
  akali findings list             # List all findings
  akali findings show AKALI-001   # Show finding details

Offensive Examples (requires authorization):
  akali attack https://example.com --web      # Web vulnerability scan
  akali attack 192.168.1.1 --network          # Network scan
  akali attack https://api.example.com --api  # API security scan
  akali attack https://example.com --full     # Full offensive scan
  akali exploit CVE-2021-44228                # CVE lookup

Fuzzing Examples (Phase 9A):
  akali fuzz binary ./app --corpus ./inputs   # Fuzz binary application
  akali fuzz network 10.0.0.5 --port 8080     # Fuzz network service
  akali fuzz analyze ./crashes --report       # Analyze crash files

Vault Examples:
  akali vault health --mock                   # Check Vault status (mock mode)
  akali vault get app/database --mock         # Get secret from Vault
  akali vault set app/api '{"key":"val"}'     # Store secret in Vault
  akali vault scan /path/to/project           # Scan for hardcoded secrets
  akali vault rotate db-password --mock       # Rotate a secret

Training Examples:
  akali train list                            # List training modules
  akali train start owasp-01-injection        # Start OWASP training
  akali train progress --agent dommo          # View progress

Status:
  akali status                    # Show Akali status

For more help: https://github.com/sevs/akali
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Scan command
    scan_parser = subparsers.add_parser("scan", help="Run security scan")
    scan_parser.add_argument("target", help="Target directory or file to scan")
    scan_parser.add_argument("--secrets-only", action="store_true", help="Run only secrets scanner")
    scan_parser.add_argument("--deps-only", action="store_true", help="Run only dependency scanner")
    scan_parser.add_argument("--sast-only", action="store_true", help="Run only SAST scanner")

    # Findings command
    findings_parser = subparsers.add_parser("findings", help="Manage findings")
    findings_subparsers = findings_parser.add_subparsers(dest="findings_command")

    list_parser = findings_subparsers.add_parser("list", help="List findings")
    list_parser.add_argument("--open", action="store_true", help="Show only open findings")
    list_parser.add_argument("--closed", action="store_true", help="Show only closed findings")
    list_parser.add_argument("--critical", action="store_true", help="Show only critical findings")
    list_parser.add_argument("--high", action="store_true", help="Show only high severity findings")
    list_parser.add_argument("--scanner", help="Filter by scanner type")

    show_parser = findings_subparsers.add_parser("show", help="Show finding details")
    show_parser.add_argument("finding_id", help="Finding ID to show")

    # Attack command (offensive)
    attack_parser = subparsers.add_parser("attack", help="‚ö†Ô∏è  Run offensive security scan (requires authorization)")
    attack_parser.add_argument("target", help="Target URL, hostname, or IP")
    attack_parser.add_argument("--web", action="store_true", help="Web vulnerability scan")
    attack_parser.add_argument("--network", action="store_true", help="Network scan")
    attack_parser.add_argument("--api", action="store_true", help="API security scan")
    attack_parser.add_argument("--full", action="store_true", help="Full offensive scan (all attack types)")
    attack_parser.add_argument("--quick", action="store_true", help="Quick scan mode")
    attack_parser.add_argument("--ports", help="Port specification for network scan (e.g., 80,443)")
    attack_parser.add_argument("--wordlist", help="Wordlist path for API endpoint discovery")

    # Exploit command with subcommands (Phase 9A)
    exploit_parser = subparsers.add_parser("exploit", help="Exploit database and CVE lookup")
    exploit_subparsers = exploit_parser.add_subparsers(dest="exploit_command")

    # Legacy CVE lookup (for backward compatibility)
    exploit_lookup_parser = exploit_subparsers.add_parser("lookup", help="Look up CVE information")
    exploit_lookup_parser.add_argument("cve_id", help="CVE identifier (e.g., CVE-2021-44228)")

    # Database search
    exploit_search_parser = exploit_subparsers.add_parser("search", help="Search exploit databases")
    exploit_search_parser.add_argument("query", help="Search query (CVE, keywords, etc.)")
    exploit_search_parser.add_argument("--source", choices=["all", "exploitdb", "github", "metasploit"], default="all", help="Source to search")
    exploit_search_parser.add_argument("--category", help="Filter by category (e.g., webapp, network)")

    # Download exploit
    exploit_download_parser = exploit_subparsers.add_parser("download", help="Download exploit by ID")
    exploit_download_parser.add_argument("exploit_id", help="Exploit ID (e.g., EDB-12345, GitHub URL)")
    exploit_download_parser.add_argument("--output", help="Output path (default: current directory)")

    # List exploits by category
    exploit_list_parser = exploit_subparsers.add_parser("list", help="List available exploits")
    exploit_list_parser.add_argument("--category", help="Filter by category")
    exploit_list_parser.add_argument("--platform", help="Filter by platform")

    # Generate exploit payloads (Phase 9A)
    exploit_generate_parser = exploit_subparsers.add_parser("generate", help="Generate exploit payloads")
    exploit_generate_subparsers = exploit_generate_parser.add_subparsers(dest="generate_type")

    # SQL injection payload generation
    generate_sqli_parser = exploit_generate_subparsers.add_parser("sqli", help="Generate SQL injection payloads")
    generate_sqli_parser.add_argument("--db", required=True, choices=["mysql", "postgresql", "mssql", "oracle"], help="Target database")
    generate_sqli_parser.add_argument("--type", choices=["union", "blind", "error", "stacked", "auth_bypass"], default="union", help="Payload type")
    generate_sqli_parser.add_argument("--encode", choices=["url", "hex", "base64"], help="Encode payloads")

    # XSS payload generation
    generate_xss_parser = exploit_generate_subparsers.add_parser("xss", help="Generate XSS payloads")
    generate_xss_parser.add_argument("--context", required=True, choices=["script", "html", "attribute", "url", "css", "json"], help="Injection context")
    generate_xss_parser.add_argument("--type", choices=["reflected", "stored", "dom"], default="reflected", help="XSS type")
    generate_xss_parser.add_argument("--encode", choices=["url", "html-entities", "unicode", "hex"], help="Encode payloads")
    generate_xss_parser.add_argument("--evasion", action="store_true", help="Enable filter evasion")

    # Buffer overflow payload generation
    generate_bof_parser = exploit_generate_subparsers.add_parser("bof", help="Generate buffer overflow exploit")
    generate_bof_parser.add_argument("--offset", type=int, required=True, help="Offset to return address")
    generate_bof_parser.add_argument("--shellcode", required=True, help="Shellcode (hex string or 'reverse_tcp')")
    generate_bof_parser.add_argument("--bad-chars", help="Bad characters to avoid (e.g., '00,0a,0d')")
    generate_bof_parser.add_argument("--ret-addr", help="Return address in hex (little-endian)")
    generate_bof_parser.add_argument("--output", help="Output file path")

    # ROP chain generation
    generate_rop_parser = exploit_generate_subparsers.add_parser("rop", help="Generate ROP chain")
    generate_rop_parser.add_argument("--binary", required=True, help="Path to target binary")
    generate_rop_parser.add_argument("--goal", choices=["shell", "system", "mprotect"], default="shell", help="ROP chain goal")
    generate_rop_parser.add_argument("--output", help="Output file path")

    # Fuzz command (Phase 9A)
    fuzz_parser = subparsers.add_parser("fuzz", help="Fuzzing framework for vulnerability discovery")
    fuzz_subparsers = fuzz_parser.add_subparsers(dest="fuzz_command")

    # Binary fuzzing
    fuzz_binary_parser = fuzz_subparsers.add_parser("binary", help="Fuzz binary application")
    fuzz_binary_parser.add_argument("binary_path", help="Path to binary to fuzz")
    fuzz_binary_parser.add_argument("--corpus", required=True, help="Directory containing seed inputs")
    fuzz_binary_parser.add_argument("--timeout", type=int, default=3600, help="Fuzzing timeout in seconds (default: 3600)")

    # Network fuzzing
    fuzz_network_parser = fuzz_subparsers.add_parser("network", help="Fuzz network service")
    fuzz_network_parser.add_argument("target", help="Target hostname or IP")
    fuzz_network_parser.add_argument("--port", type=int, required=True, help="Target port")
    fuzz_network_parser.add_argument("--protocol", choices=["tcp", "udp", "http"], default="tcp", help="Protocol to fuzz (default: tcp)")
    fuzz_network_parser.add_argument("--iterations", type=int, default=1000, help="Number of iterations (default: 1000)")
    fuzz_network_parser.add_argument("--corpus", help="Optional directory with seed inputs")

    # Crash analysis
    fuzz_analyze_parser = fuzz_subparsers.add_parser("analyze", help="Analyze crash files")
    fuzz_analyze_parser.add_argument("crash_dir", help="Directory containing crash files")
    fuzz_analyze_parser.add_argument("--report", action="store_true", help="Generate detailed report")

    # Cloud command (Phase 9B)
    cloud_parser = subparsers.add_parser("cloud", help="Cloud infrastructure attacks (AWS/Azure/GCP)")
    cloud_subparsers = cloud_parser.add_subparsers(dest="cloud_command")

    enum_s3_parser = cloud_subparsers.add_parser("enum-s3", help="Enumerate AWS S3 buckets")
    enum_s3_parser.add_argument("--keyword", required=True, help="Keyword to search for")
    enum_s3_parser.add_argument("--check-public", action="store_true", help="Check for public access")

    test_iam_parser = cloud_subparsers.add_parser("test-iam", help="Test AWS IAM permissions")
    test_iam_parser.add_argument("--access-key", required=True, help="AWS access key")
    test_iam_parser.add_argument("--secret-key", required=True, help="AWS secret key")

    enum_azure_parser = cloud_subparsers.add_parser("enum-azure", help="Enumerate Azure blob storage")
    enum_azure_parser.add_argument("--keyword", required=True, help="Keyword to search for")

    enum_gcp_parser = cloud_subparsers.add_parser("enum-gcp", help="Enumerate GCP storage buckets")
    enum_gcp_parser.add_argument("--keyword", required=True, help="Keyword to search for")

    metadata_parser = cloud_subparsers.add_parser("metadata", help="Check cloud metadata service")
    metadata_parser.add_argument("--target", default="169.254.169.254", help="Metadata service IP")

    # Active Directory command (Phase 9B)
    ad_parser = subparsers.add_parser("ad", help="Active Directory attacks")
    ad_subparsers = ad_parser.add_subparsers(dest="ad_command")

    ad_enum_parser = ad_subparsers.add_parser("enum", help="Enumerate domain")
    ad_enum_parser.add_argument("--domain", required=True, help="Domain name")
    ad_enum_parser.add_argument("--user", help="Username")
    ad_enum_parser.add_argument("--password", help="Password")

    kerberoast_parser = ad_subparsers.add_parser("kerberoast", help="Kerberoasting attack")
    kerberoast_parser.add_argument("--domain", required=True, help="Domain name")
    kerberoast_parser.add_argument("--user", required=True, help="Username")
    kerberoast_parser.add_argument("--password", required=True, help="Password")

    pth_parser = ad_subparsers.add_parser("pth", help="Pass-the-Hash attack")
    pth_parser.add_argument("--username", required=True, help="Username")
    pth_parser.add_argument("--hash", required=True, help="NTLM hash")
    pth_parser.add_argument("--target", required=True, help="Target host")

    golden_ticket_parser = ad_subparsers.add_parser("golden-ticket", help="Generate Golden Ticket")
    golden_ticket_parser.add_argument("--domain", required=True, help="Domain name")
    golden_ticket_parser.add_argument("--sid", required=True, help="Domain SID")
    golden_ticket_parser.add_argument("--krbtgt-hash", required=True, help="KRBTGT hash")

    # Privilege Escalation command (Phase 9B)
    privesc_parser = subparsers.add_parser("privesc", help="Privilege escalation")
    privesc_subparsers = privesc_parser.add_subparsers(dest="privesc_command")

    privesc_enum_parser = privesc_subparsers.add_parser("enum", help="Enumerate privilege escalation vectors")
    privesc_enum_parser.add_argument("--os", choices=["windows", "linux"], help="Operating system")
    privesc_enum_parser.add_argument("--output", help="Output file path")

    check_kernel_parser = privesc_subparsers.add_parser("check-kernel", help="Check for kernel exploits")
    check_kernel_parser.add_argument("--os", required=True, choices=["windows", "linux"], help="Operating system")
    check_kernel_parser.add_argument("--version", required=True, help="OS version")

    # Purple Team command (Phase 9C)
    purple_parser = subparsers.add_parser("purple", help="Purple team testing")
    purple_subparsers = purple_parser.add_subparsers(dest="purple_command")

    create_env_parser = purple_subparsers.add_parser("create-env", help="Create test environment")
    create_env_parser.add_argument("--type", required=True, help="Environment type")

    deploy_app_parser = purple_subparsers.add_parser("deploy-app", help="Deploy vulnerable app")
    deploy_app_parser.add_argument("--name", required=True, help="App name (dvwa, juice-shop, etc.)")
    deploy_app_parser.add_argument("--port", type=int, help="Port to expose")

    test_attack_parser = purple_subparsers.add_parser("test-attack", help="Run attack simulation")
    test_attack_parser.add_argument("--type", required=True, help="Attack type")
    test_attack_parser.add_argument("--target", required=True, help="Target URL or IP")

    purple_report_parser = purple_subparsers.add_parser("report", help="Generate purple team report")
    purple_report_parser.add_argument("--simulation-id", required=True, help="Simulation ID")
    purple_report_parser.add_argument("--output", required=True, help="Output file path")
    purple_report_parser.add_argument("--format", choices=["pdf", "html", "json"], default="pdf", help="Report format")

    # Schedule command (autonomous)
    schedule_parser = subparsers.add_parser("schedule", help="Manage scheduled jobs")
    schedule_subparsers = schedule_parser.add_subparsers(dest="schedule_command")

    schedule_subparsers.add_parser("list", help="List scheduled jobs")

    schedule_run_parser = schedule_subparsers.add_parser("run", help="Run a job immediately")
    schedule_run_parser.add_argument("job_id", help="Job ID to run")

    # Daemon command (autonomous)
    daemon_parser = subparsers.add_parser("daemon", help="Manage autonomous daemons")
    daemon_subparsers = daemon_parser.add_subparsers(dest="daemon_command")

    daemon_start_parser = daemon_subparsers.add_parser("start", help="Start a daemon")
    daemon_start_parser.add_argument("type", choices=["watch", "health"], help="Daemon type")

    daemon_stop_parser = daemon_subparsers.add_parser("stop", help="Stop a daemon")
    daemon_stop_parser.add_argument("type", choices=["watch", "health"], help="Daemon type")

    daemon_subparsers.add_parser("status", help="Show daemon status")

    # Alert command (autonomous)
    alert_parser = subparsers.add_parser("alert", help="Manage alerts")
    alert_subparsers = alert_parser.add_subparsers(dest="alert_command")

    alert_send_parser = alert_subparsers.add_parser("send", help="Send alert for a finding")
    alert_send_parser.add_argument("finding_id", help="Finding ID")
    alert_send_parser.add_argument("--agent", help="Override agent ID")

    alert_list_parser = alert_subparsers.add_parser("list", help="List alerts")
    alert_list_parser.add_argument("--pending", action="store_true", help="Show only pending alerts")

    alert_ack_parser = alert_subparsers.add_parser("ack", help="Acknowledge an alert")
    alert_ack_parser.add_argument("alert_id", help="Alert ID")

    # Triage command (autonomous)
    triage_parser = subparsers.add_parser("triage", help="Automated triage")
    triage_parser.add_argument("finding_id", help="Finding ID to triage")

    # Intel command (Phase 4)
    intel_parser = subparsers.add_parser("intel", help="Threat intelligence operations")
    intel_subparsers = intel_parser.add_subparsers(dest="intel_command")

    intel_cve_parser = intel_subparsers.add_parser("cve-check", help="Check for new CVEs")
    intel_cve_parser.add_argument("--hours", type=int, default=24, help="Hours to look back (default: 24)")

    intel_lookup_parser = intel_subparsers.add_parser("cve-lookup", help="Lookup specific CVE")
    intel_lookup_parser.add_argument("cve_id", help="CVE identifier")

    intel_subparsers.add_parser("scan-deps", help="Scan all projects for dependencies")

    intel_impact_parser = intel_subparsers.add_parser("impact", help="Analyze CVE impact")
    intel_impact_parser.add_argument("cve_id", help="CVE identifier")

    intel_subparsers.add_parser("threat-feed", help="Show threat intelligence feed")

    intel_breach_parser = intel_subparsers.add_parser("breach-check", help="Check for breached emails")
    intel_breach_parser.add_argument("email", help="Email address to check")

    # Metrics command (Phase 4)
    metrics_parser = subparsers.add_parser("metrics", help="Security metrics and observatory")
    metrics_subparsers = metrics_parser.add_subparsers(dest="metrics_command")

    metrics_subparsers.add_parser("score", help="Show security scorecard")

    metrics_history_parser = metrics_subparsers.add_parser("history", help="Show score history")
    metrics_history_parser.add_argument("--days", type=int, default=30, help="Days to show (default: 30)")

    metrics_subparsers.add_parser("observatory", help="Show MTTD/MTTR metrics")

    # Dashboard command (Phase 4)
    dashboard_parser = subparsers.add_parser("dashboard", help="Web dashboard operations")
    dashboard_subparsers = dashboard_parser.add_subparsers(dest="dashboard_command")

    dashboard_start_parser = dashboard_subparsers.add_parser("start", help="Start dashboard server")
    dashboard_start_parser.add_argument("--port", type=int, default=8765, help="Port to run on (default: 8765)")
    dashboard_start_parser.add_argument("--host", default="127.0.0.1", help="Host to bind to (default: 127.0.0.1)")

    dashboard_subparsers.add_parser("status", help="Check dashboard status")

    # Incident Response Commands (Phase 5)
    # Incident command
    incident_parser = subparsers.add_parser("incident", help="Incident management")
    incident_subparsers = incident_parser.add_subparsers(dest="incident_command")

    incident_create_parser = incident_subparsers.add_parser("create", help="Create new incident")
    incident_create_parser.add_argument("title", help="Incident title")
    incident_create_parser.add_argument("--severity", required=True, choices=["low", "medium", "high", "critical"], help="Severity level")
    incident_create_parser.add_argument("--description", help="Incident description")
    incident_create_parser.add_argument("--type", help="Incident type (sql_injection, data_breach, etc.)")
    incident_create_parser.add_argument("--systems", nargs="+", help="Affected systems")

    incident_list_parser = incident_subparsers.add_parser("list", help="List incidents")
    incident_list_parser.add_argument("--status", choices=["new", "active", "contained", "resolved", "closed"], help="Filter by status")
    incident_list_parser.add_argument("--severity", choices=["low", "medium", "high", "critical"], help="Filter by severity")

    incident_show_parser = incident_subparsers.add_parser("show", help="Show incident details")
    incident_show_parser.add_argument("incident_id", help="Incident ID")

    incident_update_parser = incident_subparsers.add_parser("update", help="Update incident status")
    incident_update_parser.add_argument("incident_id", help="Incident ID")
    incident_update_parser.add_argument("status", choices=["new", "active", "contained", "resolved", "closed"], help="New status")

    incident_close_parser = incident_subparsers.add_parser("close", help="Close incident")
    incident_close_parser.add_argument("incident_id", help="Incident ID")
    incident_close_parser.add_argument("resolution", help="Resolution summary")

    # War room command
    warroom_parser = subparsers.add_parser("war-room", help="War room operations")
    warroom_subparsers = warroom_parser.add_subparsers(dest="warroom_command")

    warroom_start_parser = warroom_subparsers.add_parser("start", help="Activate war room")
    warroom_start_parser.add_argument("incident_id", help="Incident ID")

    warroom_stop_parser = warroom_subparsers.add_parser("stop", help="Deactivate war room")
    warroom_stop_parser.add_argument("--resolution", help="Resolution summary")

    warroom_subparsers.add_parser("status", help="Show war room status")

    # Playbook command
    playbook_parser = subparsers.add_parser("playbook", help="Playbook operations")
    playbook_subparsers = playbook_parser.add_subparsers(dest="playbook_command")

    playbook_subparsers.add_parser("list", help="List available playbooks")

    playbook_run_parser = playbook_subparsers.add_parser("run", help="Run a playbook")
    playbook_run_parser.add_argument("playbook_id", help="Playbook ID")
    playbook_run_parser.add_argument("incident_id", help="Incident ID")

    playbook_status_parser = playbook_subparsers.add_parser("status", help="Check playbook status")
    playbook_status_parser.add_argument("run_id", help="Playbook run ID")

    # Post-mortem command
    postmortem_parser = subparsers.add_parser("post-mortem", help="Generate post-mortem report")
    postmortem_parser.add_argument("incident_id", help="Incident ID")
    postmortem_parser.add_argument("--output", help="Output file path")

    # Training commands
    train_parser = subparsers.add_parser("train", help="Security training")
    train_subparsers = train_parser.add_subparsers(dest="train_command")

    train_subparsers.add_parser("list", help="List training modules")

    train_start_parser = train_subparsers.add_parser("start", help="Start training module")
    train_start_parser.add_argument("module_id", help="Module ID")
    train_start_parser.add_argument("--agent", default="unknown", help="Agent ID")

    train_progress_parser = train_subparsers.add_parser("progress", help="View training progress")
    train_progress_parser.add_argument("--agent", default="unknown", help="Agent ID")

    train_cert_parser = train_subparsers.add_parser("certificate", help="View certificates")
    train_cert_parser.add_argument("agent", help="Agent ID")
    train_cert_parser.add_argument("--module", help="Specific module ID")

    # Phishing simulation commands (Phase 6)
    phish_parser = subparsers.add_parser("phish", help="Phishing simulation")
    phish_subparsers = phish_parser.add_subparsers(dest="phish_command")

    phish_subparsers.add_parser("list-templates", help="List phishing email templates")

    phish_create_parser = phish_subparsers.add_parser("create-campaign", help="Create phishing campaign")
    phish_create_parser.add_argument("name", help="Campaign name")
    phish_create_parser.add_argument("--template", required=True, help="Template ID")
    phish_create_parser.add_argument("--targets", required=True, help="Targets JSON file")
    phish_create_parser.add_argument("--description", help="Campaign description")

    phish_list_parser = phish_subparsers.add_parser("list-campaigns", help="List campaigns")
    phish_list_parser.add_argument("--status", choices=["draft", "scheduled", "active", "paused", "completed", "cancelled"], help="Filter by status")

    phish_send_parser = phish_subparsers.add_parser("send", help="Send campaign emails")
    phish_send_parser.add_argument("campaign_id", help="Campaign ID")
    phish_send_parser.add_argument("--dry-run", action="store_true", help="Test mode (no emails sent)")

    phish_report_parser = phish_subparsers.add_parser("report", help="View campaign report")
    phish_report_parser.add_argument("campaign_id", help="Campaign ID")

    phish_export_parser = phish_subparsers.add_parser("export", help="Export campaign report")
    phish_export_parser.add_argument("campaign_id", help="Campaign ID")
    phish_export_parser.add_argument("--output", help="Output file path")

    phish_tracker_parser = phish_subparsers.add_parser("start-tracker", help="Start click tracking server")
    phish_tracker_parser.add_argument("--host", default="127.0.0.1", help="Host to bind to")
    phish_tracker_parser.add_argument("--port", type=int, default=5555, help="Port to run on")

    # Vault commands (Phase 6)
    vault_parser = subparsers.add_parser("vault", help="HashiCorp Vault operations")
    vault_subparsers = vault_parser.add_subparsers(dest="vault_command")

    vault_get_parser = vault_subparsers.add_parser("get", help="Get secret from Vault")
    vault_get_parser.add_argument("path", help="Secret path")
    vault_get_parser.add_argument("--version", type=int, help="Secret version")
    vault_get_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_set_parser = vault_subparsers.add_parser("set", help="Set secret in Vault")
    vault_set_parser.add_argument("path", help="Secret path")
    vault_set_parser.add_argument("data", help="Secret data (JSON)")
    vault_set_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_list_parser = vault_subparsers.add_parser("list", help="List secrets in Vault")
    vault_list_parser.add_argument("path", nargs="?", default="", help="Secret path prefix")
    vault_list_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_delete_parser = vault_subparsers.add_parser("delete", help="Delete secret from Vault")
    vault_delete_parser.add_argument("path", help="Secret path")
    vault_delete_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_rotate_parser = vault_subparsers.add_parser("rotate", help="Rotate a secret")
    vault_rotate_parser.add_argument("policy_id", help="Rotation policy ID")
    vault_rotate_parser.add_argument("--force", action="store_true", help="Force rotation")
    vault_rotate_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_scan_parser = vault_subparsers.add_parser("scan", help="Scan for hardcoded secrets")
    vault_scan_parser.add_argument("target", help="File or directory to scan")
    vault_scan_parser.add_argument("--output", help="Save report to file (JSON)")

    vault_health_parser = vault_subparsers.add_parser("health", help="Check Vault health")
    vault_health_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_policies_parser = vault_subparsers.add_parser("policies", help="Manage rotation policies")
    vault_policies_subparsers = vault_policies_parser.add_subparsers(dest="vault_policies_command")

    vault_policies_list_parser = vault_policies_subparsers.add_parser("list", help="List rotation policies")
    vault_policies_list_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    vault_policies_check_parser = vault_policies_subparsers.add_parser("check", help="Check for due rotations")
    vault_policies_check_parser.add_argument("--mock", action="store_true", help="Use mock Vault client")

    # DLP commands
    dlp_parser = subparsers.add_parser("dlp", help="Data Loss Prevention (DLP) operations")
    dlp_subparsers = dlp_parser.add_subparsers(dest="dlp_command")

    dlp_scan_parser = dlp_subparsers.add_parser("scan", help="Scan for PII violations")
    dlp_scan_parser.add_argument("target", help="File, directory, or payload to scan")
    dlp_scan_parser.add_argument("--type", choices=["file", "git", "api"], default="file", help="Scan type")

    dlp_violations_parser = dlp_subparsers.add_parser("violations", help="Manage DLP violations")
    dlp_violations_subparsers = dlp_violations_parser.add_subparsers(dest="dlp_violations_command")

    dlp_violations_list_parser = dlp_violations_subparsers.add_parser("list", help="List violations")
    dlp_violations_list_parser.add_argument("--severity", choices=["critical", "high", "medium", "low"], help="Filter by severity")

    dlp_violations_show_parser = dlp_violations_subparsers.add_parser("show", help="Show violation details")
    dlp_violations_show_parser.add_argument("violation_id", help="Violation ID")

    dlp_violations_clear_parser = dlp_violations_subparsers.add_parser("clear", help="Clear all violations")

    dlp_policies_parser = dlp_subparsers.add_parser("policies", help="Manage DLP policies")
    dlp_policies_subparsers = dlp_policies_parser.add_subparsers(dest="dlp_policies_command")

    dlp_policies_list_parser = dlp_policies_subparsers.add_parser("list", help="List policies")

    dlp_policies_enable_parser = dlp_policies_subparsers.add_parser("enable", help="Enable policy")
    dlp_policies_enable_parser.add_argument("policy_id", help="Policy ID")

    dlp_policies_disable_parser = dlp_policies_subparsers.add_parser("disable", help="Disable policy")
    dlp_policies_disable_parser.add_argument("policy_id", help="Policy ID")

    dlp_monitor_parser = dlp_subparsers.add_parser("monitor", help="Start DLP monitoring")
    dlp_monitor_parser.add_argument("--file", action="store_true", help="Monitor file system")
    dlp_monitor_parser.add_argument("--git", action="store_true", help="Install git hook or check staged")
    dlp_monitor_parser.add_argument("--api", action="store_true", help="Start API monitor demo")
    dlp_monitor_parser.add_argument("--paths", nargs="+", help="Paths to monitor (for file monitor)")
    dlp_monitor_parser.add_argument("--port", type=int, default=5050, help="API monitor port")
    dlp_monitor_parser.add_argument("--action", choices=["check", "install"], default="check", help="Git action")

    # Threat Hunting commands
    hunt_parser = subparsers.add_parser("hunt", help="Advanced threat hunting operations")
    hunt_subparsers = hunt_parser.add_subparsers(dest="hunt_command")

    hunt_analyze_parser = hunt_subparsers.add_parser("analyze", help="Analyze logs for threats")
    hunt_analyze_parser.add_argument("log_file", help="Log file to analyze (JSON format)")
    hunt_analyze_parser.add_argument("--type", choices=["auto", "login", "network", "api", "file"], default="auto", help="Analysis type")

    hunt_ioc_parser = hunt_subparsers.add_parser("ioc", help="Check IoC against database")
    hunt_ioc_parser.add_argument("indicator", help="Indicator to check (IP, domain, hash)")

    hunt_ioc_import_parser = hunt_subparsers.add_parser("ioc-import", help="Import IoCs from file")
    hunt_ioc_import_parser.add_argument("feed_file", help="IoC feed file (JSON)")
    hunt_ioc_import_parser.add_argument("--name", default="custom", help="Feed name")

    hunt_report_parser = hunt_subparsers.add_parser("report", help="Generate threat report")
    hunt_report_parser.add_argument("findings_file", help="Findings file (JSON)")
    hunt_report_parser.add_argument("--format", choices=["markdown", "html", "json"], default="markdown", help="Report format")

    hunt_stats_parser = hunt_subparsers.add_parser("stats", help="Show hunting statistics")

    # Phase 7: Mobile pentesting commands
    mobile_parser = subparsers.add_parser("mobile", help="Mobile penetration testing")
    mobile_subparsers = mobile_parser.add_subparsers(dest="mobile_command")

    mobile_static_parser = mobile_subparsers.add_parser("static", help="Static analysis")
    mobile_static_parser.add_argument("target", help="APK or IPA file")
    mobile_static_parser.add_argument("--platform", choices=["android", "ios"], default="android")

    # Phase 7: C2 commands
    c2_parser = subparsers.add_parser("c2", help="Command & Control")
    c2_subparsers = c2_parser.add_subparsers(dest="c2_command")

    c2_agent_parser = c2_subparsers.add_parser("agent", help="Agent management")
    c2_agent_subparsers = c2_agent_parser.add_subparsers(dest="agent_action")
    c2_agent_subparsers.add_parser("list", help="List agents")

    c2_task_parser = c2_subparsers.add_parser("task", help="Task management")
    c2_task_subparsers = c2_task_parser.add_subparsers(dest="task_action")
    task_send_parser = c2_task_subparsers.add_parser("send", help="Send task")
    task_send_parser.add_argument("agent_id", help="Agent ID")
    task_send_parser.add_argument("command", help="Command to execute")
    task_send_parser.add_argument("--args", default="", help="Command arguments")

    # Phase 7: Red team campaign commands
    redteam_parser = subparsers.add_parser("redteam", help="Red team operations")
    redteam_subparsers = redteam_parser.add_subparsers(dest="redteam_command")

    campaign_parser = redteam_subparsers.add_parser("campaign", help="Campaign management")
    campaign_subparsers = campaign_parser.add_subparsers(dest="campaign_action")

    campaign_create_parser = campaign_subparsers.add_parser("create", help="Create campaign")
    campaign_create_parser.add_argument("name", help="Campaign name")
    campaign_create_parser.add_argument("--target", required=True, help="Target")
    campaign_create_parser.add_argument("--mode", choices=["red", "purple"], default="purple")
    campaign_create_parser.add_argument("--template", default="mobile-test", help="Campaign template")

    campaign_run_parser = campaign_subparsers.add_parser("run", help="Run campaign")
    campaign_run_parser.add_argument("campaign_id", help="Campaign ID")

    # Phase 8: Wireless security commands
    wireless_parser = subparsers.add_parser("wireless", help="Wireless security testing")
    wireless_subparsers = wireless_parser.add_subparsers(dest="wireless_command")

    wireless_wifi_parser = wireless_subparsers.add_parser("wifi", help="WiFi security")
    wireless_wifi_subparsers = wireless_wifi_parser.add_subparsers(dest="wifi_action")

    wireless_wifi_subparsers.add_parser("scan", help="Scan for WiFi networks")

    wifi_analyze_parser = wireless_wifi_subparsers.add_parser("analyze", help="Analyze WiFi pcap")
    wifi_analyze_parser.add_argument("pcap_file", help="Path to pcap file")

    wireless_ble_parser = wireless_subparsers.add_parser("ble", help="Bluetooth Low Energy")
    wireless_ble_subparsers = wireless_ble_parser.add_subparsers(dest="ble_action")

    ble_scan_parser = wireless_ble_subparsers.add_parser("scan", help="Scan for BLE devices")
    ble_scan_parser.add_argument("--timeout", type=int, default=10, help="Scan timeout (seconds)")

    # Phase 8: IoT security commands
    iot_parser = subparsers.add_parser("iot", help="IoT security testing")
    iot_subparsers = iot_parser.add_subparsers(dest="iot_command")

    iot_scan_parser = iot_subparsers.add_parser("scan", help="Scan network for IoT devices")
    iot_scan_parser.add_argument("network", help="Network to scan (e.g., 192.168.1.0/24)")
    iot_scan_parser.add_argument("--timeout", type=int, default=30, help="Scan timeout (seconds)")

    iot_mqtt_parser = iot_subparsers.add_parser("mqtt", help="MQTT protocol testing")
    iot_mqtt_subparsers = iot_mqtt_parser.add_subparsers(dest="mqtt_action")

    mqtt_probe_parser = iot_mqtt_subparsers.add_parser("probe", help="Probe MQTT broker")
    mqtt_probe_parser.add_argument("host", help="MQTT broker hostname/IP")
    mqtt_probe_parser.add_argument("--port", type=int, default=1883, help="MQTT port")
    mqtt_probe_parser.add_argument("--timeout", type=int, default=5, help="Connection timeout")

    iot_coap_parser = iot_subparsers.add_parser("coap", help="CoAP protocol testing")
    iot_coap_subparsers = iot_coap_parser.add_subparsers(dest="coap_action")

    coap_probe_parser = iot_coap_subparsers.add_parser("probe", help="Probe CoAP server")
    coap_probe_parser.add_argument("host", help="CoAP server hostname/IP")
    coap_probe_parser.add_argument("--port", type=int, default=5683, help="CoAP port")
    coap_probe_parser.add_argument("--timeout", type=int, default=5, help="Connection timeout")

    iot_firmware_parser = iot_subparsers.add_parser("firmware", help="Firmware analysis")
    iot_firmware_subparsers = iot_firmware_parser.add_subparsers(dest="firmware_action")

    firmware_extract_parser = iot_firmware_subparsers.add_parser("extract", help="Extract firmware")
    firmware_extract_parser.add_argument("firmware_file", help="Path to firmware file")

    firmware_scan_parser = iot_firmware_subparsers.add_parser("scan", help="Scan firmware for secrets")
    firmware_scan_parser.add_argument("firmware_path", help="Path to extracted firmware directory")

    # Status command
    subparsers.add_parser("status", help="Show Akali status")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    cli = AkaliCLI()

    try:
        if args.command == "scan":
            # Determine which scanners to run
            scanner_types = []
            if args.secrets_only:
                scanner_types = ["secrets"]
            elif args.deps_only:
                scanner_types = ["dependencies"]
            elif args.sast_only:
                scanner_types = ["sast"]

            print(f"ü•∑ Akali: Scanning {args.target}...\n")
            findings = cli.scan(args.target, scanner_types if scanner_types else None)

            if findings:
                print(f"\n‚ö†Ô∏è  Found {len(findings)} security issues")
                print(f"   Run 'akali findings list' to see details")
                sys.exit(1)
            else:
                print(f"\n‚úÖ No security issues found")
                sys.exit(0)

        elif args.command == "findings":
            if args.findings_command == "list":
                status = None
                if args.open:
                    status = "open"
                elif args.closed:
                    status = "closed"

                severity = None
                if args.critical:
                    severity = "critical"
                elif args.high:
                    severity = "high"

                cli.list_findings(status=status, severity=severity, scanner=args.scanner)

            elif args.findings_command == "show":
                cli.show_finding(args.finding_id)

            else:
                findings_parser.print_help()

        elif args.command == "attack":
            # Determine attack type
            if args.web:
                attack_type = "web"
            elif args.network:
                attack_type = "network"
            elif args.api:
                attack_type = "api"
            elif args.full:
                attack_type = "full"
            else:
                # Default to full if no specific type
                attack_type = "full"

            print(f"ü•∑ Akali: Offensive scan on {args.target}\n")

            # Pass additional kwargs
            kwargs = {}
            if args.ports:
                kwargs["ports"] = args.ports
            if args.wordlist:
                kwargs["wordlist"] = args.wordlist

            findings = cli.attack(args.target, attack_type=attack_type, quick=args.quick, **kwargs)

            if findings:
                print(f"\n‚ö†Ô∏è  Found {len(findings)} security issues")
                print(f"   Run 'akali findings list' to see details")
                sys.exit(1)
            else:
                print(f"\n‚úÖ No critical vulnerabilities found")
                sys.exit(0)

        elif args.command == "exploit":
            if args.exploit_command == "lookup":
                cli.exploit(args.cve_id)
            elif args.exploit_command == "search":
                cli.exploit_search(args.query, source=args.source, category=args.category)
            elif args.exploit_command == "download":
                cli.exploit_download(args.exploit_id, output_path=args.output)
            elif args.exploit_command == "list":
                cli.exploit_list(category=args.category, platform=args.platform)
            elif args.exploit_command == "generate":
                if args.generate_type == "sqli":
                    cli.exploit_generate_sqli(db=args.db, payload_type=args.type, encoding=args.encode)
                elif args.generate_type == "xss":
                    cli.exploit_generate_xss(context=args.context, xss_type=args.type,
                                            encoding=args.encode, evasion=args.evasion)
                elif args.generate_type == "bof":
                    cli.exploit_generate_bof(offset=args.offset, shellcode=args.shellcode,
                                            bad_chars=args.bad_chars, ret_addr=args.ret_addr,
                                            output=args.output)
                elif args.generate_type == "rop":
                    cli.exploit_generate_rop(binary=args.binary, goal=args.goal, output=args.output)
                else:
                    exploit_generate_parser.print_help()
            elif hasattr(args, 'cve_id'):  # Backward compat: no subcommand but cve_id arg
                cli.exploit(args.cve_id)
            else:
                exploit_parser.print_help()

        elif args.command == "fuzz":
            if args.fuzz_command == "binary":
                cli.fuzz_binary(args.binary_path, args.corpus, timeout=args.timeout)
            elif args.fuzz_command == "network":
                cli.fuzz_network(args.target, args.port, protocol=args.protocol,
                               iterations=args.iterations, corpus_dir=args.corpus)
            elif args.fuzz_command == "analyze":
                cli.fuzz_analyze(args.crash_dir, report=args.report)
            else:
                fuzz_parser.print_help()

        elif args.command == "cloud":
            if args.cloud_command == "enum-s3":
                cli.cloud_enum_s3(keyword=args.keyword, check_public=args.check_public)
            elif args.cloud_command == "test-iam":
                cli.cloud_test_iam(access_key=args.access_key, secret_key=args.secret_key)
            elif args.cloud_command == "enum-azure":
                cli.cloud_enum_azure(keyword=args.keyword)
            elif args.cloud_command == "enum-gcp":
                cli.cloud_enum_gcp(keyword=args.keyword)
            elif args.cloud_command == "metadata":
                cli.cloud_metadata(target=args.target)
            else:
                cloud_parser.print_help()

        elif args.command == "ad":
            if args.ad_command == "enum":
                cli.ad_enumerate(domain=args.domain, username=args.user, password=args.password)
            elif args.ad_command == "kerberoast":
                cli.ad_kerberoast(domain=args.domain, username=args.user, password=args.password)
            elif args.ad_command == "pth":
                cli.ad_pass_the_hash(username=args.username, ntlm_hash=args.hash, target=args.target)
            elif args.ad_command == "golden-ticket":
                cli.ad_golden_ticket(domain=args.domain, sid=args.sid, krbtgt_hash=args.krbtgt_hash)
            else:
                ad_parser.print_help()

        elif args.command == "privesc":
            if args.privesc_command == "enum":
                cli.privesc_enumerate(os_type=args.os, output=args.output)
            elif args.privesc_command == "check-kernel":
                cli.privesc_check_kernel(os_type=args.os, version=args.version)
            else:
                privesc_parser.print_help()

        elif args.command == "purple":
            if args.purple_command == "create-env":
                cli.purple_create_environment(env_type=args.type)
            elif args.purple_command == "deploy-app":
                cli.purple_deploy_app(app_name=args.name, port=args.port)
            elif args.purple_command == "test-attack":
                cli.purple_test_attack(attack_type=args.type, target=args.target)
            elif args.purple_command == "report":
                cli.purple_generate_report(simulation_id=args.simulation_id,
                                          output_path=args.output,
                                          format=args.format)
            else:
                purple_parser.print_help()

        elif args.command == "schedule":
            if args.schedule_command == "list":
                cli.schedule_list()
            elif args.schedule_command == "run":
                cli.schedule_run(args.job_id)
            else:
                schedule_parser.print_help()

        elif args.command == "daemon":
            if args.daemon_command == "start":
                cli.daemon_start(args.type)
            elif args.daemon_command == "stop":
                cli.daemon_stop(args.type)
            elif args.daemon_command == "status":
                cli.daemon_status()
            else:
                daemon_parser.print_help()

        elif args.command == "alert":
            if args.alert_command == "send":
                cli.alert_send(args.finding_id, agent_id=args.agent if hasattr(args, 'agent') else None)
            elif args.alert_command == "list":
                cli.alert_list(pending=args.pending)
            elif args.alert_command == "ack":
                cli.alert_ack(args.alert_id)
            else:
                alert_parser.print_help()

        elif args.command == "triage":
            cli.triage_finding(args.finding_id)

        elif args.command == "intel":
            if args.intel_command == "cve-check":
                cli.intel_cve_check(hours=args.hours)
            elif args.intel_command == "cve-lookup":
                cli.intel_cve_lookup(args.cve_id)
            elif args.intel_command == "scan-deps":
                cli.intel_scan_deps()
            elif args.intel_command == "impact":
                cli.intel_impact(args.cve_id)
            elif args.intel_command == "threat-feed":
                cli.intel_threat_feed()
            elif args.intel_command == "breach-check":
                cli.intel_breach_check(args.email)
            else:
                intel_parser.print_help()

        elif args.command == "metrics":
            if args.metrics_command == "score" or not args.metrics_command:
                cli.metrics_score()
            elif args.metrics_command == "history":
                cli.metrics_history(days=args.days)
            elif args.metrics_command == "observatory":
                cli.metrics_observatory()
            else:
                metrics_parser.print_help()

        elif args.command == "dashboard":
            if args.dashboard_command == "start":
                cli.dashboard_start(host=args.host, port=args.port)
            elif args.dashboard_command == "status":
                cli.dashboard_status()
            else:
                dashboard_parser.print_help()

        elif args.command == "incident":
            if args.incident_command == "create":
                cli.incident_create(
                    title=args.title,
                    severity=args.severity,
                    description=args.description,
                    incident_type=args.type,
                    systems=args.systems
                )
            elif args.incident_command == "list":
                cli.incident_list(status=args.status, severity=args.severity)
            elif args.incident_command == "show":
                cli.incident_show(args.incident_id)
            elif args.incident_command == "update":
                cli.incident_update(args.incident_id, args.status)
            elif args.incident_command == "close":
                cli.incident_close(args.incident_id, args.resolution)
            else:
                incident_parser.print_help()

        elif args.command == "war-room":
            if args.warroom_command == "start":
                cli.war_room_start(args.incident_id)
            elif args.warroom_command == "stop":
                cli.war_room_stop(resolution=args.resolution)
            elif args.warroom_command == "status":
                cli.war_room_status()
            else:
                warroom_parser.print_help()

        elif args.command == "playbook":
            if args.playbook_command == "list":
                cli.playbook_list()
            elif args.playbook_command == "run":
                cli.playbook_run(args.playbook_id, args.incident_id)
            elif args.playbook_command == "status":
                cli.playbook_status(args.run_id)
            else:
                playbook_parser.print_help()

        elif args.command == "post-mortem":
            cli.post_mortem(args.incident_id, output=args.output)

        elif args.command == "train":
            if args.train_command == "list":
                cli.train_list()
            elif args.train_command == "start":
                cli.train_start(args.module_id, agent_id=args.agent)
            elif args.train_command == "progress":
                cli.train_progress(agent_id=args.agent)
            elif args.train_command == "certificate":
                cli.train_certificate(args.agent, module_id=args.module)
            else:
                train_parser.print_help()

        elif args.command == "phish":
            if args.phish_command == "list-templates":
                cli.phish_list_templates()
            elif args.phish_command == "create-campaign":
                cli.phish_create_campaign(
                    name=args.name,
                    template_id=args.template,
                    targets_file=args.targets,
                    description=args.description
                )
            elif args.phish_command == "list-campaigns":
                cli.phish_list_campaigns(status=args.status)
            elif args.phish_command == "send":
                cli.phish_send(args.campaign_id, dry_run=args.dry_run)
            elif args.phish_command == "report":
                cli.phish_report(args.campaign_id)
            elif args.phish_command == "export":
                cli.phish_export(args.campaign_id, output=args.output)
            elif args.phish_command == "start-tracker":
                cli.phish_start_tracker(host=args.host, port=args.port)
            else:
                phish_parser.print_help()

        elif args.command == "vault":
            if args.vault_command == "get":
                cli.vault_get(args.path, version=args.version, mock=args.mock)

            elif args.vault_command == "set":
                cli.vault_set(args.path, args.data, mock=args.mock)

            elif args.vault_command == "list":
                cli.vault_list(args.path, mock=args.mock)

            elif args.vault_command == "delete":
                cli.vault_delete(args.path, mock=args.mock)

            elif args.vault_command == "rotate":
                cli.vault_rotate(args.policy_id, force=args.force, mock=args.mock)

            elif args.vault_command == "scan":
                cli.vault_scan(args.target, output=args.output)

            elif args.vault_command == "health":
                cli.vault_health(mock=args.mock)

            elif args.vault_command == "policies":
                if args.vault_policies_command == "list":
                    cli.vault_policies_list(mock=args.mock)
                elif args.vault_policies_command == "check":
                    cli.vault_policies_check(mock=args.mock)
                else:
                    vault_policies_parser.print_help()

            else:
                vault_parser.print_help()

        elif args.command == "dlp":
            if args.dlp_command == "scan":
                cli.dlp_scan(args.target, scan_type=args.type)

            elif args.dlp_command == "violations":
                if args.dlp_violations_command == "list":
                    cli.dlp_violations_list(severity=args.severity)
                elif args.dlp_violations_command == "show":
                    cli.dlp_violations_show(args.violation_id)
                elif args.dlp_violations_command == "clear":
                    cli.dlp_violations_clear()
                else:
                    dlp_violations_parser.print_help()

            elif args.dlp_command == "policies":
                if args.dlp_policies_command == "list":
                    cli.dlp_policies_list()
                elif args.dlp_policies_command == "enable":
                    cli.dlp_policies_enable(args.policy_id)
                elif args.dlp_policies_command == "disable":
                    cli.dlp_policies_disable(args.policy_id)
                else:
                    dlp_policies_parser.print_help()

            elif args.dlp_command == "monitor":
                if args.file:
                    cli.dlp_monitor_file(paths=args.paths)
                elif args.git:
                    cli.dlp_monitor_git(action=args.action)
                elif args.api:
                    cli.dlp_monitor_api(port=args.port)
                else:
                    dlp_monitor_parser.print_help()

            else:
                dlp_parser.print_help()

        elif args.command == "hunt":
            if args.hunt_command == "analyze":
                cli.hunt_analyze(args.log_file, analysis_type=args.type)

            elif args.hunt_command == "ioc":
                cli.hunt_ioc(args.indicator)

            elif args.hunt_command == "ioc-import":
                cli.hunt_ioc_import(args.feed_file, feed_name=args.name)

            elif args.hunt_command == "report":
                cli.hunt_report(args.findings_file, output_format=args.format)

            elif args.hunt_command == "stats":
                cli.hunt_stats()

            else:
                hunt_parser.print_help()

        # Phase 7: Mobile commands
        elif args.command == "mobile":
            if args.mobile_command == "static":
                cli.mobile_static(args.target, platform=args.platform)
            else:
                mobile_parser.print_help()

        # Phase 7: C2 commands
        elif args.command == "c2":
            if args.c2_command == "agent":
                if args.agent_action == "list":
                    cli.c2_agent_list()
                else:
                    c2_agent_parser.print_help()

            elif args.c2_command == "task":
                if args.task_action == "send":
                    cli.c2_task_send(args.agent_id, args.command, args=args.args)
                else:
                    c2_task_parser.print_help()

            else:
                c2_parser.print_help()

        # Phase 7: Red team campaign commands
        elif args.command == "redteam":
            if args.redteam_command == "campaign":
                if args.campaign_action == "create":
                    cli.redteam_campaign_create(args.name, args.target, args.mode, args.template)
                elif args.campaign_action == "run":
                    cli.redteam_campaign_run(args.campaign_id)
                else:
                    campaign_parser.print_help()
            else:
                redteam_parser.print_help()

        # Phase 8: Wireless security commands
        elif args.command == "wireless":
            if args.wireless_command == "wifi":
                if args.wifi_action == "scan":
                    cli.wireless_wifi_scan()
                elif args.wifi_action == "analyze":
                    cli.wireless_wifi_analyze(args.pcap_file)
                else:
                    wireless_wifi_parser.print_help()

            elif args.wireless_command == "ble":
                if args.ble_action == "scan":
                    cli.wireless_ble_scan(timeout=args.timeout)
                else:
                    wireless_ble_parser.print_help()

            else:
                wireless_parser.print_help()

        # Phase 8: IoT security commands
        elif args.command == "iot":
            if args.iot_command == "scan":
                cli.iot_scan(args.network, timeout=args.timeout)

            elif args.iot_command == "mqtt":
                if args.mqtt_action == "probe":
                    cli.iot_mqtt_probe(args.host, port=args.port, timeout=args.timeout)
                else:
                    iot_mqtt_parser.print_help()

            elif args.iot_command == "coap":
                if args.coap_action == "probe":
                    cli.iot_coap_probe(args.host, port=args.port, timeout=args.timeout)
                else:
                    iot_coap_parser.print_help()

            elif args.iot_command == "firmware":
                if args.firmware_action == "extract":
                    cli.iot_firmware_extract(args.firmware_file)
                elif args.firmware_action == "scan":
                    cli.iot_firmware_scan(args.firmware_path)
                else:
                    iot_firmware_parser.print_help()

            else:
                iot_parser.print_help()

        elif args.command == "status":
            cli.status()

    except KeyboardInterrupt:
        print("\n\nüëã Interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n‚ùå Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
