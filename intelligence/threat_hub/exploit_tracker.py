#!/usr/bin/env python3
"""
Exploit Tracker - Track public exploits for CVEs
"""

import json
import os
import re
import requests
from datetime import datetime
from typing import Dict, List, Optional


class ExploitTracker:
    """Track exploits from Exploit-DB and GitHub"""

    def __init__(self, github_token: Optional[str] = None):
        """
        Initialize exploit tracker

        Args:
            github_token: Optional GitHub token for API
        """
        self.github_token = github_token
        self.cache_file = os.path.expanduser("~/akali/intelligence/threat_hub/exploit_cache.json")
        self.cache = self._load_cache()

    def _load_cache(self) -> Dict:
        """Load exploit cache from disk"""
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Warning: Failed to load cache: {e}")
        return {"exploits": {}, "last_updated": None}

    def _save_cache(self):
        """Save exploit cache to disk"""
        os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
        with open(self.cache_file, 'w') as f:
            json.dump(self.cache, f, indent=2)

    def search_exploits_for_cve(self, cve_id: str) -> List[Dict]:
        """
        Search for exploits related to a CVE

        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)

        Returns:
            List of exploit dictionaries
        """
        # Check cache first
        if cve_id in self.cache["exploits"]:
            cached = self.cache["exploits"][cve_id]
            print(f"Found {len(cached)} exploit(s) in cache for {cve_id}")
            return cached

        print(f"Searching for exploits: {cve_id}")

        exploits = []

        # Search GitHub
        github_exploits = self._search_github(cve_id)
        exploits.extend(github_exploits)

        # Search Exploit-DB (via search engines or scraping)
        exploitdb_exploits = self._search_exploitdb(cve_id)
        exploits.extend(exploitdb_exploits)

        # Update cache
        self.cache["exploits"][cve_id] = exploits
        self.cache["last_updated"] = datetime.now().isoformat()
        self._save_cache()

        return exploits

    def _search_github(self, cve_id: str) -> List[Dict]:
        """
        Search GitHub for PoCs and exploits

        Args:
            cve_id: CVE identifier

        Returns:
            List of GitHub repository dictionaries
        """
        exploits = []

        # Search GitHub Code for CVE references
        query = f"{cve_id} exploit OR poc"
        url = "https://api.github.com/search/repositories"
        params = {"q": query, "sort": "stars", "order": "desc", "per_page": 10}

        headers = {"Accept": "application/vnd.github.v3+json"}
        if self.github_token:
            headers["Authorization"] = f"token {self.github_token}"

        try:
            response = requests.get(url, params=params, headers=headers, timeout=30)
            response.raise_for_status()

            data = response.json()
            items = data.get("items", [])

            for repo in items:
                # Filter for likely exploits (not just documentation)
                if any(keyword in repo["name"].lower() for keyword in ["poc", "exploit", "vulnerability"]):
                    exploits.append({
                        "source": "GitHub",
                        "name": repo["full_name"],
                        "url": repo["html_url"],
                        "description": repo.get("description", ""),
                        "stars": repo["stargazers_count"],
                        "language": repo.get("language", "Unknown"),
                        "updated": repo["updated_at"],
                    })

        except requests.exceptions.RequestException as e:
            print(f"Error searching GitHub: {e}")

        return exploits

    def _search_exploitdb(self, cve_id: str) -> List[Dict]:
        """
        Search Exploit-DB for exploits

        Note: Exploit-DB doesn't have a public API. This is a simple
        web scraping approach. For production, consider using
        their database CSV export or Google CSE API.

        Args:
            cve_id: CVE identifier

        Returns:
            List of Exploit-DB dictionaries
        """
        exploits = []

        try:
            # Search Exploit-DB via their search page
            url = f"https://www.exploit-db.com/search?cve={cve_id}"
            headers = {"User-Agent": "Akali Security Scanner"}

            response = requests.get(url, headers=headers, timeout=30)
            response.raise_for_status()

            # Simple regex to extract exploit links from HTML
            # Format: /exploits/12345
            matches = re.findall(r'/exploits/(\d+)', response.text)

            for exploit_id in set(matches):  # Deduplicate
                exploit_url = f"https://www.exploit-db.com/exploits/{exploit_id}"
                exploits.append({
                    "source": "Exploit-DB",
                    "id": exploit_id,
                    "url": exploit_url,
                    "description": f"Exploit-DB entry for {cve_id}",
                })

        except requests.exceptions.RequestException as e:
            print(f"Error searching Exploit-DB: {e}")

        return exploits

    def check_exploit_availability(self, cve_id: str) -> bool:
        """
        Check if public exploit exists for CVE

        Args:
            cve_id: CVE identifier

        Returns:
            True if exploit found, False otherwise
        """
        exploits = self.search_exploits_for_cve(cve_id)
        return len(exploits) > 0

    def get_exploit_summary(self, cve_id: str) -> Dict:
        """
        Get exploit summary for CVE

        Args:
            cve_id: CVE identifier

        Returns:
            Summary dictionary
        """
        exploits = self.search_exploits_for_cve(cve_id)

        if not exploits:
            return {
                "cve_id": cve_id,
                "exploit_available": False,
                "exploit_count": 0,
                "sources": [],
            }

        # Group by source
        sources = {}
        for exploit in exploits:
            source = exploit["source"]
            if source not in sources:
                sources[source] = []
            sources[source].append(exploit)

        return {
            "cve_id": cve_id,
            "exploit_available": True,
            "exploit_count": len(exploits),
            "sources": list(sources.keys()),
            "exploits": exploits,
        }


def main():
    """CLI for exploit tracking"""
    import sys

    tracker = ExploitTracker()

    if len(sys.argv) < 2:
        print("Usage:")
        print("  python exploit_tracker.py search <CVE-ID>    # Search for exploits")
        print("  python exploit_tracker.py check <CVE-ID>     # Check if exploit exists")
        sys.exit(1)

    command = sys.argv[1]

    if command == "search":
        if len(sys.argv) < 3:
            print("Error: CVE ID required")
            sys.exit(1)

        cve_id = sys.argv[2]
        summary = tracker.get_exploit_summary(cve_id)

        print(f"\n{'='*80}")
        print(f"Exploit Search: {cve_id}")
        print(f"{'='*80}\n")

        if summary["exploit_available"]:
            print(f"ðŸš¨ Exploit Available: YES")
            print(f"Found {summary['exploit_count']} exploit(s) from {len(summary['sources'])} source(s)\n")

            for exploit in summary["exploits"]:
                print(f"Source: {exploit['source']}")
                if exploit["source"] == "GitHub":
                    print(f"  Repo: {exploit['name']}")
                    print(f"  Stars: {exploit['stars']}")
                    print(f"  Language: {exploit['language']}")
                else:  # Exploit-DB
                    print(f"  ID: {exploit['id']}")
                print(f"  URL: {exploit['url']}")
                print(f"  Description: {exploit['description']}")
                print()
        else:
            print("âœ… No public exploits found")

    elif command == "check":
        if len(sys.argv) < 3:
            print("Error: CVE ID required")
            sys.exit(1)

        cve_id = sys.argv[2]
        available = tracker.check_exploit_availability(cve_id)

        if available:
            print(f"ðŸš¨ {cve_id}: Public exploit AVAILABLE")
        else:
            print(f"âœ… {cve_id}: No public exploit found")

    else:
        print(f"Unknown command: {command}")
        sys.exit(1)


if __name__ == "__main__":
    main()
