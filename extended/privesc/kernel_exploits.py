"""Kernel exploit database management."""

import json
from pathlib import Path
from typing import List, Dict, Optional


class KernelExploitDB:
    """Kernel exploit database for privilege escalation."""

    def __init__(self, db_path: Optional[str] = None):
        """Initialize kernel exploit database.

        Args:
            db_path: Path to JSON database file (default: kernel_exploits.json)
        """
        if db_path is None:
            self.db_path = Path(__file__).parent / 'kernel_exploits.json'
        else:
            self.db_path = Path(db_path)

    def _load_database(self) -> Dict:
        """Load kernel exploit database from JSON.

        Returns:
            Dictionary with 'windows' and 'linux' exploit lists
        """
        try:
            with open(self.db_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {'windows': [], 'linux': []}
        except json.JSONDecodeError:
            return {'windows': [], 'linux': []}

    def search(self, os_type: str, version: str) -> List[Dict]:
        """Search for kernel exploits matching OS version.

        Args:
            os_type: Operating system type ('windows' or 'linux')
            version: OS version string

        Returns:
            List of matching exploits
        """
        db = self._load_database()
        os_type = os_type.lower()

        if os_type not in db:
            return []

        matches = []
        for exploit in db[os_type]:
            if self._version_matches(version, exploit.get('versions', [])):
                matches.append(exploit)

        return matches

    def get_by_cve(self, cve: str) -> Optional[Dict]:
        """Get exploit by CVE identifier.

        Args:
            cve: CVE identifier (e.g., 'CVE-2021-3493')

        Returns:
            Exploit dictionary or None if not found
        """
        db = self._load_database()

        for os_exploits in db.values():
            for exploit in os_exploits:
                if exploit.get('cve', '').upper() == cve.upper():
                    return exploit

        return None

    def filter_by_severity(self, exploits: List[Dict], severity: str) -> List[Dict]:
        """Filter exploits by severity level.

        Args:
            exploits: List of exploits
            severity: Severity level ('critical', 'high', 'medium', 'low')

        Returns:
            Filtered list of exploits
        """
        return [e for e in exploits if e.get('severity', '').lower() == severity.lower()]

    def filter_by_exploit_available(self, exploits: List[Dict], available: bool) -> List[Dict]:
        """Filter exploits by exploit availability.

        Args:
            exploits: List of exploits
            available: True to filter for available exploits

        Returns:
            Filtered list of exploits
        """
        return [e for e in exploits if e.get('exploit_available', False) == available]

    def _version_matches(self, target_version: str, exploit_versions: List[str]) -> bool:
        """Check if target version matches exploit versions.

        Args:
            target_version: Target OS version
            exploit_versions: List of vulnerable versions (supports ranges)

        Returns:
            True if version matches
        """
        if isinstance(exploit_versions, str):
            exploit_versions = [exploit_versions]

        target_lower = target_version.lower()

        for version in exploit_versions:
            version_lower = version.lower()

            # Exact match
            if target_lower in version_lower or version_lower in target_lower:
                return True

            # Range match (e.g., "Windows 10 1809-2004")
            if '-' in version_lower:
                # Simple substring match for ranges
                base_os = version_lower.split()[0:2]  # e.g., ['windows', '10']
                if all(part in target_lower for part in base_os):
                    return True

        return False

    def add_exploit(self, os_type: str, exploit: Dict) -> bool:
        """Add new exploit to database.

        Args:
            os_type: Operating system type ('windows' or 'linux')
            exploit: Exploit dictionary

        Returns:
            True if successfully added
        """
        if not self._validate_exploit_entry(exploit):
            return False

        db = self._load_database()
        os_type = os_type.lower()

        if os_type not in db:
            db[os_type] = []

        # Check for duplicates
        if any(e.get('cve') == exploit.get('cve') for e in db[os_type]):
            return False

        db[os_type].append(exploit)

        try:
            with open(self.db_path, 'w') as f:
                json.dump(db, f, indent=2)
            return True
        except Exception:
            return False

    def export_database(self, output_path: str) -> bool:
        """Export database to file.

        Args:
            output_path: Output file path

        Returns:
            True if successfully exported
        """
        db = self._load_database()

        try:
            with open(output_path, 'w') as f:
                json.dump(db, f, indent=2)
            return True
        except Exception:
            return False

    def get_statistics(self) -> Dict:
        """Get database statistics.

        Returns:
            Dictionary with statistics
        """
        db = self._load_database()

        stats = {
            'total': sum(len(exploits) for exploits in db.values()),
            'windows': len(db.get('windows', [])),
            'linux': len(db.get('linux', []))
        }

        return stats

    def search_by_keyword(self, keyword: str) -> List[Dict]:
        """Search exploits by keyword in name or description.

        Args:
            keyword: Search keyword

        Returns:
            List of matching exploits
        """
        db = self._load_database()
        keyword_lower = keyword.lower()
        matches = []

        for os_exploits in db.values():
            for exploit in os_exploits:
                name = exploit.get('name', '').lower()
                desc = exploit.get('description', '').lower()

                if keyword_lower in name or keyword_lower in desc:
                    matches.append(exploit)

        return matches

    def get_latest_exploits(self, limit: int = 10) -> List[Dict]:
        """Get latest exploits by CVE year.

        Args:
            limit: Maximum number of results

        Returns:
            List of latest exploits
        """
        db = self._load_database()
        all_exploits = []

        for os_exploits in db.values():
            all_exploits.extend(os_exploits)

        # Sort by CVE year (descending)
        def get_cve_year(exploit):
            cve = exploit.get('cve', 'CVE-0000-0000')
            try:
                year = int(cve.split('-')[1])
                return year
            except (IndexError, ValueError):
                return 0

        sorted_exploits = sorted(all_exploits, key=get_cve_year, reverse=True)
        return sorted_exploits[:limit]

    def _validate_exploit_entry(self, exploit: Dict) -> bool:
        """Validate exploit entry has required fields.

        Args:
            exploit: Exploit dictionary

        Returns:
            True if valid
        """
        required_fields = ['cve', 'name', 'versions', 'severity', 'exploit_available', 'references']

        for field in required_fields:
            if field not in exploit:
                return False

        return True
