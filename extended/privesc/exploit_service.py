"""Service exploitation for privilege escalation."""

import subprocess
import os
import shutil
from pathlib import Path
from typing import Dict, List, Optional


class ServiceExploiter:
    """Service exploitation for Windows privilege escalation."""

    def __init__(self):
        """Initialize service exploiter."""
        pass

    def exploit_unquoted_service_path(
        self,
        service_name: str,
        service_path: str,
        payload_path: str
    ) -> Dict:
        """Exploit unquoted service path vulnerability.

        Args:
            service_name: Service name
            service_path: Unquoted service path with spaces
            payload_path: Path to payload executable

        Returns:
            Exploitation result
        """
        result = {
            'success': False,
            'message': '',
            'steps': []
        }

        try:
            # Calculate exploit paths
            exploit_paths = self._calculate_exploit_paths(service_path)

            if not exploit_paths:
                result['message'] = 'No valid exploit paths found'
                return result

            # Find first writable path
            writable_path = None
            for path in exploit_paths:
                if self._is_path_writable(os.path.dirname(path)):
                    writable_path = path
                    break

            if not writable_path:
                result['message'] = 'No writable exploit paths found'
                return result

            result['steps'].append(f'Identified writable path: {writable_path}')

            # Copy payload (simulation - don't actually exploit)
            result['steps'].append(f'Copy payload to: {writable_path}')
            result['steps'].append(f'Restart service: {service_name}')
            result['steps'].append('Payload would execute with service privileges')

            result['success'] = True
            result['message'] = 'Exploitation steps identified (simulation only)'
            result['exploit_path'] = writable_path

        except Exception as e:
            result['message'] = f'Exploitation failed: {str(e)}'

        return result

    def exploit_weak_permissions(self, service_name: str, payload_path: str) -> Dict:
        """Exploit weak service permissions.

        Args:
            service_name: Service name
            payload_path: Path to payload executable

        Returns:
            Exploitation result
        """
        result = {
            'success': False,
            'message': '',
            'steps': []
        }

        try:
            # Verify service is writable
            if not self._verify_service_writable(service_name):
                result['message'] = 'Service is not writable'
                return result

            result['steps'].append(f'Verified write access to service: {service_name}')

            # Get current service binary path
            binary_path = self._get_service_binary_path(service_name)
            if not binary_path:
                result['message'] = 'Could not retrieve service binary path'
                return result

            result['steps'].append(f'Current binary: {binary_path}')

            # Backup original binary
            result['steps'].append(f'Backup original binary')

            # Replace with payload
            result['steps'].append(f'Replace with payload: {payload_path}')

            # Restart service
            result['steps'].append(f'Restart service to execute payload')

            result['success'] = True
            result['message'] = 'Exploitation steps identified (simulation only)'

        except Exception as e:
            result['message'] = f'Exploitation failed: {str(e)}'

        return result

    def exploit_dll_hijacking(
        self,
        target_binary: str,
        missing_dll: str,
        payload_dll: str
    ) -> Dict:
        """Exploit DLL hijacking vulnerability.

        Args:
            target_binary: Target application binary
            missing_dll: Missing DLL name
            payload_dll: Malicious DLL path

        Returns:
            Exploitation result
        """
        result = {
            'success': False,
            'message': '',
            'steps': []
        }

        try:
            binary_dir = os.path.dirname(target_binary)

            if not self._is_path_writable(binary_dir):
                result['message'] = 'Target directory is not writable'
                return result

            dll_path = os.path.join(binary_dir, missing_dll)

            result['steps'].append(f'Identified writable directory: {binary_dir}')
            result['steps'].append(f'Copy malicious DLL to: {dll_path}')
            result['steps'].append(f'DLL will be loaded when {os.path.basename(target_binary)} runs')

            result['success'] = True
            result['message'] = 'DLL hijacking steps identified (simulation only)'
            result['dll_path'] = dll_path

        except Exception as e:
            result['message'] = f'Exploitation failed: {str(e)}'

        return result

    def exploit_registry_autorun(
        self,
        registry_key: str,
        value_name: str,
        payload_path: str
    ) -> Dict:
        """Exploit registry autorun for persistence.

        Args:
            registry_key: Registry key path
            value_name: Registry value name
            payload_path: Path to payload

        Returns:
            Exploitation result
        """
        result = {
            'success': False,
            'message': '',
            'steps': []
        }

        try:
            result['steps'].append(f'Add registry value: {registry_key}\\{value_name}')
            result['steps'].append(f'Set value to: {payload_path}')
            result['steps'].append('Payload will execute on user logon')

            result['success'] = True
            result['message'] = 'Registry autorun steps identified (simulation only)'

        except Exception as e:
            result['message'] = f'Exploitation failed: {str(e)}'

        return result

    def exploit_scheduled_task(self, task_name: str, payload_path: str) -> Dict:
        """Exploit scheduled task for persistence.

        Args:
            task_name: Scheduled task name
            payload_path: Path to payload

        Returns:
            Exploitation result
        """
        result = {
            'success': False,
            'message': '',
            'steps': []
        }

        try:
            result['steps'].append(f'Modify scheduled task: {task_name}')
            result['steps'].append(f'Change task action to: {payload_path}')
            result['steps'].append('Payload will execute on task schedule')

            result['success'] = True
            result['message'] = 'Scheduled task exploitation steps identified (simulation only)'

        except Exception as e:
            result['message'] = f'Exploitation failed: {str(e)}'

        return result

    def _verify_service_writable(self, service_name: str) -> bool:
        """Verify service has write permissions.

        Args:
            service_name: Service name

        Returns:
            True if writable
        """
        try:
            result = subprocess.run(
                ['sc', 'sdshow', service_name],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Check for write permissions in SDDL
                sddl = result.stdout.strip()
                # Simplified check - look for Everyone (WD) or Authenticated Users (AU)
                return 'WD' in sddl or 'AU' in sddl

        except Exception:
            pass

        return False

    def _get_service_binary_path(self, service_name: str) -> Optional[str]:
        """Get service binary path.

        Args:
            service_name: Service name

        Returns:
            Binary path or None
        """
        try:
            result = subprocess.run(
                ['sc', 'qc', service_name],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'BINARY_PATH_NAME' in line:
                        path = line.split('BINARY_PATH_NAME')[1].strip().strip(':').strip()
                        return path.strip('"')

        except Exception:
            pass

        return None

    def _backup_service_binary(self, binary_path: str) -> bool:
        """Backup service binary.

        Args:
            binary_path: Path to service binary

        Returns:
            True if backup successful
        """
        try:
            backup_path = f'{binary_path}.bak'
            shutil.copy2(binary_path, backup_path)
            return True
        except Exception:
            return False

    def _restore_service_binary(self, binary_path: str) -> bool:
        """Restore service binary from backup.

        Args:
            binary_path: Path to service binary

        Returns:
            True if restore successful
        """
        try:
            backup_path = f'{binary_path}.bak'
            if os.path.exists(backup_path):
                shutil.move(backup_path, binary_path)
                return True
        except Exception:
            pass

        return False

    def _stop_service(self, service_name: str) -> bool:
        """Stop a Windows service.

        Args:
            service_name: Service name

        Returns:
            True if stopped successfully
        """
        try:
            result = subprocess.run(
                ['sc', 'stop', service_name],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode == 0
        except Exception:
            return False

    def _start_service(self, service_name: str) -> bool:
        """Start a Windows service.

        Args:
            service_name: Service name

        Returns:
            True if started successfully
        """
        try:
            result = subprocess.run(
                ['sc', 'start', service_name],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode == 0
        except Exception:
            return False

    def _calculate_exploit_paths(self, service_path: str) -> List[str]:
        """Calculate exploit paths for unquoted service path.

        Args:
            service_path: Unquoted service path with spaces

        Returns:
            List of potential exploit paths
        """
        paths = []

        # Remove .exe extension
        if service_path.endswith('.exe'):
            service_path = service_path[:-4]

        parts = service_path.split()

        # Build exploit paths
        for i in range(1, len(parts)):
            exploit_path = ' '.join(parts[:i]) + '.exe'
            paths.append(exploit_path)

        return paths

    def _is_path_writable(self, path: str) -> bool:
        """Check if path is writable.

        Args:
            path: Path to check

        Returns:
            True if writable
        """
        try:
            return os.access(path, os.W_OK)
        except Exception:
            return False

    def _generate_exploit_payload(
        self,
        payload_type: str,
        lhost: str = '127.0.0.1',
        lport: int = 4444
    ) -> str:
        """Generate exploit payload (simulation).

        Args:
            payload_type: Type of payload
            lhost: Listener host
            lport: Listener port

        Returns:
            Payload description
        """
        payloads = {
            'reverse_shell': f'Reverse shell to {lhost}:{lport}',
            'add_user': 'Add administrative user',
            'enable_rdp': 'Enable Remote Desktop',
            'disable_firewall': 'Disable Windows Firewall'
        }

        return payloads.get(payload_type, 'Custom payload')
